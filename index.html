<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Dopple Talent Demo</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0e0f12; --bg-2:#08090c;
      --panel:#12131a; --panel-2:#1a1b25;
      --text:#ececf1; --muted:#b7b8c3;
      --stroke:#26283a; --stroke-strong:#3a3b52;
      --accent:#8a8cff;
      --ok:#16db65; --warn:#ffd166; --stop:#ff6b6b;
      --shadow:0 10px 30px rgba(0,0,0,.35); --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 80% -10%, rgba(94,97,255,.12), transparent 40%),
        radial-gradient(900px 480px at 0% 110%, rgba(138,140,255,.10), transparent 45%),
        linear-gradient(180deg,var(--bg),var(--bg-2));
      min-height:100vh;
    }

    /* Layout */
    .wrap{max-width:1100px; margin:0 auto; padding:28px 20px 48px}
    .card{
      position:relative;
      background:linear-gradient(180deg,var(--panel),var(--panel-2));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:26px 22px 32px;
      margin:18px 0;
    }
    .section{max-width:980px; margin:0 auto}
    .stack-s{margin-top:8px}
    .stack-m{margin-top:16px}
    .stack-l{margin-top:24px}
    .stack-xl{margin-top:32px}

    /* Reset Session button */
    .reset{
      position:absolute; right:18px; top:18px;
      appearance:none; border:1px solid var(--stroke-strong);
      background:#191a23; color:#cfd0dc; font-size:12px;
      border-radius:12px; padding:8px 10px; cursor:pointer;
    }
    .reset:hover{filter:brightness(1.05)}

    /* BIG mic button */
    .mic-rail{display:flex; justify-content:center}
    .mic{
      appearance:none; border:none; cursor:pointer;
      padding:18px 26px; border-radius:18px;
      font-size:18px; line-height:1; letter-spacing:.4px;
      font-family:'Montserrat',sans-serif; font-weight:800; text-transform:uppercase;
      background:linear-gradient(180deg,#fff,#eee); color:#000;
      box-shadow:0 8px 20px rgba(0,0,0,.25);
      min-width:240px;
      transition:transform .15s ease, opacity .15s ease, background .15s ease;
    }
    .mic:hover{transform:translateY(-1px)}
    .mic:active{transform:translateY(0)}
    .mic.listening{background:linear-gradient(180deg,var(--warn),#ffdf8a)}
    .mic.stopping{background:linear-gradient(180deg,var(--stop),#ff8a8a); color:#000}
    .mic[disabled]{opacity:.45; cursor:not-allowed}

    /* Status pill */
    .status-rail{display:flex; justify-content:center}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      background:#191a23; border:1px solid var(--stroke-strong);
      color:#cfd0dc; border-radius:999px; padding:7px 12px;
      font-size:12px; letter-spacing:.2px;
      box-shadow:0 6px 16px rgba(0,0,0,.25);
    }
    .dot{width:8px; height:8px; border-radius:999px; background:#666}
    .pill.listening .dot{background:#f7c948}
    .pill.thinking  .dot{background:#8a8cff}
    .pill.speaking  .dot{background:#16db65}
    .pill.ready     .dot{background:#6f7284}

    /* Instructions */
    .instructions{
      text-align:center;
      font-family:'Montserrat',sans-serif; font-weight:800; text-transform:uppercase;
      color:#d8d9e3; letter-spacing:.4px; font-size:14px;
    }
    .instructions small{display:block; color:#bfc1cd; margin-top:6px; font-size:9px}

    /* Prompt buttons */
    .prompt-grid{
      display:flex; flex-wrap:wrap; justify-content:center;
      gap:12px 14px;
      margin:18px auto 36px;
      max-width:1000px;
      padding:0 6px;
    }
    .btn{
      appearance:none; border:none; cursor:pointer;
      padding:10px 14px;
      border-radius:16px; font-size:12px;
      font-family:'Montserrat',sans-serif; font-weight:700; text-transform:uppercase;
      background:linear-gradient(180deg,#fff,#efefef); color:#000;
      border:1px solid #e7e7e7;
      white-space:nowrap;
      transition:transform .15s ease, opacity .15s ease;
    }
    .btn:hover{transform:translateY(-1px)}
    .btn[disabled]{opacity:.45; cursor:not-allowed}
    .btn.active{background:linear-gradient(180deg,#e9ebff,#dfe1ff); border-color:#cfd1ff}

    /* Video */
    .hero{display:flex; justify-content:center; position:relative}
    #resp{
      width:min(100%,560px); aspect-ratio:9/16; max-height:70vh;
      border-radius:14px; background:#000;
      border:1px solid var(--stroke-strong);
      box-shadow:0 12px 32px rgba(0,0,0,.35);
      opacity:1; transition:opacity 320ms ease;
      cursor:pointer; outline:none;
    }
    #resp:focus-visible{box-shadow:0 0 0 3px var(--accent)}
    .fade-start{opacity:0}

    /* Buffering overlay */
    .overlay {
      position:absolute; inset:0; display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.18); border-radius:14px;
      pointer-events:none;
    }
    .overlay.show{display:flex}
    .spinner{
      width:38px; height:38px; border-radius:999px;
      border:3px solid rgba(255,255,255,.35);
      border-top-color:#fff; animation:spin 900ms linear infinite;
      box-shadow:0 0 18px rgba(255,255,255,.25);
    }
    @keyframes spin{to{transform:rotate(360deg)}}

    .footer{font-size:12px; color:#b7b8c3; text-align:center; margin-top:26px; margin-bottom:60px}

    /* Toast */
    .toast{
      position:absolute; left:50%; bottom:20px; transform:translateX(-50%);
      background:#1b1c25; color:#eaeaf1; border:1px solid var(--stroke-strong);
      padding:10px 14px; border-radius:12px; box-shadow:var(--shadow);
      font-size:12px; letter-spacing:.2px;
      opacity:0; pointer-events:none; transition:opacity .20s ease;
    }
    .toast.show{opacity:1}

    /* SR-only */
    .sr-only{
      position:absolute !important; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); border:0;
    }

    @media (max-width:480px){
      .mic{min-width:195px; font-size:16px; padding:16px 22px}
      .btn{width:100%}
      #resp{max-height:68vh}
      .prompt-grid{gap:10px 12px; margin:14px auto 26px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card section">
      <!-- Reset Session (Tier 1 memory) -->
      <button class="reset" id="resetBtn" type="button" title="Reset session (clears local memory)">Reset Session</button>

      <!-- BIG mic button -->
      <div class="mic-rail">
        <button class="mic" id="micBtn" aria-pressed="false">ðŸŽ¤ Tap to Talk</button>
      </div>

      <!-- status pill -->
      <div class="status-rail stack-s">
        <div id="statusPill" class="pill ready" aria-live="polite">
          <span class="dot"></span><span id="pillText">Ready</span>
        </div>
      </div>

      <!-- instructions -->
      <div class="instructions stack-l">
        Ask Sasha one of these 3 questions.
        <small>If your microphone doesn't work, tap the question.</small>
      </div>

      <!-- prompt buttons -->
      <div class="prompt-grid stack-m" id="promptGrid">
        <button class="btn" data-file="assets/p_fun.mp4">What do you like to do for fun?</button>
        <button class="btn" data-file="assets/p_from.mp4">Where are you from?</button>
        <button class="btn" data-file="assets/p_relax.mp4">What's your favorite way to relax?</button>
      </div>

      <!-- response video + overlay -->
      <div class="hero">
        <video id="resp" playsinline preload="auto" tabindex="0" aria-label="Response video (tap to play or pause)"></video>
        <div id="overlay" class="overlay" aria-hidden="true"><div class="spinner"></div></div>
      </div>

      <!-- screen-reader-only status -->
      <div class="sr-only" aria-live="polite" id="asrStatus">Idle</div>

      <div class="footer">
        <div style="margin-bottom: 20px;">
          <h3 style="color: var(--text); margin: 0 0 12px; font-family: 'Montserrat', sans-serif; font-weight: 800;">Create Your AI DoppelgÃ¤nger</h3>
          <p style="color: var(--muted); margin: 0 0 20px; line-height: 1.5;">
            Upload a photo and voice sample to create a talking AI version of yourself. 
            Perfect for professional networking, job interviews, and personal branding.
          </p>
          <a href="/upload.html" style="display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, var(--accent), #9b9dff); color: #000; text-decoration: none; border-radius: 12px; font-weight: 600; font-family: 'Montserrat', sans-serif; text-transform: uppercase; letter-spacing: 0.5px;">
            Create Your DOP
          </a>
        </div>
        <div style="font-size: 12px; color: #b7b8c3;">
          AI built by Michelle McCormack Â·
          <span id="memInfo">Session memory: Local (Tier 1). Context window capped to last 10 turns.</span>
        </div>
      </div>

      <!-- Toast -->
      <div id="toast" class="toast" role="status" aria-live="polite"></div>
    </div>
  </div>

  <script>
    /* ============================================================
       Constants & Configuration
       ============================================================ */
    const MAX_TURNS = 10;
    const MIC_LOCK_DURATION_MS = 350;
    const ASR_DEBOUNCE_MS = 500;
    const TOAST_DISPLAY_MS = 1500;
    const TTS_FALLBACK_TIMEOUT_MS = 12000;

    const VOICE_MAP = {
      fun:  "WEyBkfNR4P8pL1cFo2jV",
      from: "DqdcNywG9XLHBlbqaZYM",
      relax:"IcsVrJwpE5wPKqWalifC",
    };
    const FALLBACK_VOICE = "kDIJK53VQMjfQj3fCrML";

    const CLIP_META = {
      "assets/p_fun.mp4": {
        transcript: "I'm a go-out girlâ€”coffee walks, thrifting, and a little dancing never hurt. ðŸ˜‰"
      },
      "assets/p_from.mp4": {
        transcript: "I'm East-coast raised with a Boston edgeâ€”but I've bounced around enough to pick up good pizza opinions."
      },
      "assets/p_relax.mp4": {
        transcript: "Headphones on, hot shower, then a cozy movie night. Zero drama, maximum exhale."
      }
    };

    /* ============================================================
       Global State Namespace
       ============================================================ */
    window.DTA = {
      selectedVoiceId: FALLBACK_VOICE,
      lastPromptKey: null,
      sessionId: generateSessionId(),
      conversationHistory: []
    };

    /* ============================================================
       Utility Functions
       ============================================================ */
    function generateSessionId() {
      if (crypto && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      // Fallback for older browsers
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    function haptic(ms = 12) {
      if (navigator.vibrate) {
        try { 
          navigator.vibrate(ms);
        } catch (e) {
          console.warn('Haptic feedback failed:', e);
        }
      }
    }

    /* ============================================================
       Session Memory Management
       ============================================================ */
    function pushTurn(role, content, meta = {}) {
      window.DTA.conversationHistory.push({ 
        role, 
        content: String(content || ''), 
        ts: Date.now(), 
        meta 
      });
      
      if (window.DTA.conversationHistory.length > MAX_TURNS) {
        window.DTA.conversationHistory.splice(
          0, 
          window.DTA.conversationHistory.length - MAX_TURNS
        );
      }
    }

    function getBoundedContext() {
      const system = { 
        role: 'system', 
        content: 'You are Sasha â€” be brief, warm, playful. Respect boundaries.' 
      };
      return [system, ...window.DTA.conversationHistory.slice(-MAX_TURNS)];
    }

    function resetSession() {
      window.DTA.conversationHistory.length = 0;
      window.DTA.sessionId = generateSessionId();
      window.DTA.lastPromptKey = null;
      window.DTA.selectedVoiceId = FALLBACK_VOICE;
      
      stopAll();
      setIdleUI();
      clearPreloadCache();
      
      console.log('[DTA] Session reset â†’', window.DTA.sessionId);
      showToast('Session reset');
    }

    /* ============================================================
       Voice Selection
       ============================================================ */
    function setVoiceByPromptFile(file) {
      try {
        const key = String(file || "")
          .replace(/^assets\//, "")
          .replace(/\.mp4$/i, "")
          .replace(/^p_/, ""); // p_fun -> fun
        
        window.DTA.selectedVoiceId = VOICE_MAP[key] || FALLBACK_VOICE;
        window.DTA.lastPromptKey = key;
      } catch (e) {
        console.error('Voice selection error:', e);
        window.DTA.selectedVoiceId = FALLBACK_VOICE;
      }
    }

    function getSelectedVoiceId() {
      return window.DTA.selectedVoiceId || FALLBACK_VOICE;
    }

    /* ============================================================
       Toast Notifications
       ============================================================ */
    const toastEl = document.getElementById('toast');
    let toastTimer = null;

    function showToast(msg) {
      if (!toastEl) return;
      
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        toastEl.classList.remove('show');
      }, TOAST_DISPLAY_MS);
    }

    /* ============================================================
       DOM Elements
       ============================================================ */
    const resp = document.getElementById('resp');
    const grid = document.getElementById('promptGrid');
    const promptButtons = Array.from(grid.querySelectorAll('.btn'));
    const micBtn = document.getElementById('micBtn');
    const srStatus = document.getElementById('asrStatus');
    const pill = document.getElementById('statusPill');
    const pillText = document.getElementById('pillText');
    const overlay = document.getElementById('overlay');
    const resetBtn = document.getElementById('resetBtn');

    /* ============================================================
       State Management
       ============================================================ */
    let currentFile = 'assets/p_fun.mp4';
    let currentAudio = null;
    let currentAudioURL = null;
    let lastMode = null;  // 'video' | 'tts'
    let lastFile = null;
    let lastText = null;

    // Mic locking state
    let micLocked = false;
    let micLockTimer = null;

    function lockMic(ms = MIC_LOCK_DURATION_MS) {
      micLocked = true;
      clearTimeout(micLockTimer);
      micLockTimer = setTimeout(() => {
        micLocked = false;
      }, ms);
    }

    // Video preload cache
    const preloadCache = new Map();

    function clearPreloadCache() {
      preloadCache.forEach(video => {
        try {
          video.pause();
          video.src = '';
          video.load();
        } catch (e) {
          console.warn('Video cleanup error:', e);
        }
      });
      preloadCache.clear();
    }

    /* ============================================================
       UI State Functions
       ============================================================ */
    function setPill(mode, text) {
      pill.classList.remove('listening', 'thinking', 'speaking', 'ready');
      pill.classList.add(mode);
      pillText.textContent = text;
    }

    function showOverlay() { 
      overlay.classList.add('show'); 
    }

    function hideOverlay() { 
      overlay.classList.remove('show'); 
    }

    function setListeningUI() {
      micBtn.textContent = 'â–  Stop';
      micBtn.classList.add('listening');
      micBtn.classList.remove('stopping');
      micBtn.setAttribute('aria-pressed', 'true');
      disablePrompts(true);
      setPill('listening', 'Listeningâ€¦');
    }

    function setPlayingUI() {
      micBtn.textContent = 'â–  Stop';
      micBtn.classList.add('stopping');
      micBtn.classList.remove('listening');
      micBtn.setAttribute('aria-pressed', 'true');
      disablePrompts(true);
      setPill('speaking', 'Speakingâ€¦');
    }

    function setIdleUI() {
      micBtn.textContent = 'ðŸŽ¤ Tap to Talk';
      micBtn.classList.remove('listening', 'stopping');
      micBtn.setAttribute('aria-pressed', 'false');
      disablePrompts(false);
      srStatus.textContent = 'Idle';
      setPill('ready', 'Ready');
    }

    function clearActive() { 
      promptButtons.forEach(b => b.classList.remove('active')); 
    }

    function setActiveByFile(file) {
      clearActive();
      const btn = promptButtons.find(b => b.dataset.file === file);
      if (btn) btn.classList.add('active');
    }

    function disablePrompts(disabled) { 
      promptButtons.forEach(b => b.disabled = !!disabled); 
    }

    /* ============================================================
       Audio Cleanup (Single Source of Truth)
       ============================================================ */
    function cleanupAudio() {
      try {
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.src = '';
          currentAudio = null;
        }
        if (currentAudioURL) {
          URL.revokeObjectURL(currentAudioURL);
          currentAudioURL = null;
        }
        if ('speechSynthesis' in window) {
          speechSynthesis.cancel();
        }
      } catch (e) {
        console.warn('Audio cleanup error:', e);
      }
    }

    function stopVideo() {
      try {
        resp.pause();
        resp.currentTime = 0;
        clearActive();
      } catch (e) {
        console.warn('Video stop error:', e);
      }
    }

    function stopAll() {
      cleanupAudio();
      stopVideo();
      setIdleUI();
      haptic();
    }

    /* ============================================================
       Video Preloading
       ============================================================ */
    function primeFirstFrame(src) {
      showOverlay();
      resp.classList.add('fade-start');
      resp.src = src;
      
      try {
        resp.load();
      } catch (e) {
        console.error('Video load error:', e);
      }

      resp.addEventListener('loadeddata', () => {
        resp.pause();
        resp.currentTime = 0;
        requestAnimationFrame(() => resp.classList.remove('fade-start'));
        hideOverlay();
        setPill('ready', 'Ready');
      }, { once: true });
    }

    function preloadSources(initialSrc) {
      const uniqueSrcs = [...new Set(promptButtons.map(b => b.dataset.file))];
      
      uniqueSrcs.forEach(src => {
        if (src === initialSrc) return;
        if (preloadCache.has(src)) return;
        
        const v = document.createElement('video');
        v.preload = 'auto';
        v.src = src;
        v.addEventListener('loadeddata', () => {
          console.log('[DTA] Preloaded:', src);
        }, { once: true });
        
        try { 
          v.load(); 
        } catch (e) {
          console.warn('Preload error for', src, e);
        }
        
        preloadCache.set(src, v);
      });
    }

    /* ============================================================
       Video Playback
       ============================================================ */
    function playFile(file) {
      cleanupAudio();

      const labelBtn = promptButtons.find(b => b.dataset.file === file);
      if (labelBtn) {
        pushTurn('user', labelBtn.textContent.trim(), { inputType: 'prompt', file });
      } else {
        pushTurn('user', 'Clicked prompt', { inputType: 'prompt', file });
      }

      if (currentFile === file && !resp.paused) {
        stopVideo();
        setIdleUI();
        hideOverlay();
        return;
      }

      currentFile = file;
      setActiveByFile(file);
      setPlayingUI();
      showOverlay();

      lastMode = 'video';
      lastFile = file;
      lastText = null;

      resp.classList.add('fade-start');
      resp.src = file;
      
      try {
        resp.load();
      } catch (e) {
        console.error('Video load error:', e);
        hideOverlay();
        setIdleUI();
        return;
      }

      const onCanPlay = () => {
        const meta = CLIP_META[file] || {};
        const textForMemory = meta.transcript || `Playing clip: ${file.split('/').pop()}`;
        pushTurn('assistant', textForMemory, { videoUrl: file, clip: file });

        const playPromise = resp.play();
        if (playPromise && typeof playPromise.catch === 'function') {
          playPromise.catch(e => {
            console.warn('Video play error:', e);
            setIdleUI();
            hideOverlay();
          });
        }
        
        requestAnimationFrame(() => resp.classList.remove('fade-start'));
        hideOverlay();
      };
      
      resp.addEventListener('canplay', onCanPlay, { once: true });

      if (window.innerWidth < 900) {
        resp.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    /* ============================================================
       Video Event Handlers
       ============================================================ */
    resp.addEventListener('click', () => {
      if (resp.paused) {
        const playPromise = resp.play();
        if (playPromise && typeof playPromise.catch === 'function') {
          playPromise.catch(e => console.warn('Play error:', e));
        }
        setPlayingUI();
      } else {
        stopVideo();
        setIdleUI();
        hideOverlay();
      }
    });

    resp.addEventListener('ended', () => {
      stopVideo();
      setIdleUI();
    });

    resp.addEventListener('error', (e) => {
      console.error('Video error:', e);
      stopVideo();
      setIdleUI();
      hideOverlay();
    });

    /* ============================================================
       Prompt Button Handlers
       ============================================================ */
    grid.addEventListener('click', (e) => {
      const btn = e.target.closest('.btn');
      if (!btn) return;
      
      const file = btn.dataset.file;
      setVoiceByPromptFile(file);
      playFile(file);
    });

    /* ============================================================
       Speech Recognition (ASR)
       ============================================================ */
    const supportsASR = ('SpeechRecognition' in window) || ('webkitSpeechRecognition' in window);
    let recognizer = null;
    let recognizing = false;
    let finalTranscript = '';
    let asrProcessed = false;
    let asrDebounceTimer = null;

    if (!supportsASR) {
      micBtn.disabled = true;
      srStatus.textContent = 'Speech input not available.';
    }

    function initRecognizer() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognizer = new SR();
      recognizer.lang = 'en-US';
      recognizer.interimResults = true;
      recognizer.continuous = false;

      recognizer.onstart = () => {
        recognizing = true;
        finalTranscript = '';
        asrProcessed = false;
        
        stopAll();
        setListeningUI();
        srStatus.textContent = 'Listeningâ€¦';
        lockMic();
        haptic();
      };

      recognizer.onerror = (e) => {
        console.error('ASR error:', e);
        srStatus.textContent = 'Mic error: ' + (e.error || 'unknown');
        stopASR();
        setIdleUI();
        hideOverlay();
      };

      recognizer.onend = () => {
        recognizing = false;
        if (!asrProcessed) {
          setIdleUI();
        }
      };

      recognizer.onresult = (event) => {
        // Accumulate all final results
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const result = event.results[i];
          if (result.isFinal) {
            finalTranscript += result[0].transcript.trim() + ' ';
          }
        }

        // Debounce processing to batch multiple final results
        clearTimeout(asrDebounceTimer);
        asrDebounceTimer = setTimeout(() => {
          const text = finalTranscript.trim();
          if (text && !asrProcessed) {
            asrProcessed = true;
            processTranscript(text);
          }
        }, ASR_DEBOUNCE_MS);
      };
    }

    function processTranscript(text) {
      try {
        stopASR();
      } catch (e) {
        console.warn('ASR stop error:', e);
      }
      
      pushTurn('user', text, { inputType: 'mic' });
      srStatus.textContent = 'Processingâ€¦';
      setPill('thinking', 'Thinkingâ€¦');
      routeToBackend(text, { forceLLM: true });
    }

    function startASR() {
      if (!recognizer) {
        initRecognizer();
      }
      
      try {
        recognizer.start();
      } catch (e) {
        console.warn('ASR start error, retrying:', e);
        try {
          recognizer.stop();
          setTimeout(() => recognizer.start(), 100);
        } catch (e2) {
          console.error('ASR restart failed:', e2);
        }
      }
    }

    function stopASR() {
      if (recognizer && recognizing) {
        try {
          recognizer.stop();
        } catch (e) {
          console.warn('ASR stop error:', e);
        }
      }
      recognizing = false;
      clearTimeout(asrDebounceTimer);
    }

    /* ============================================================
       Mic Button Handler
       ============================================================ */
    micBtn.addEventListener('click', () => {
      if (micLocked) return;
      
      if (micBtn.textContent.includes('Stop')) {
        stopAll();
        lockMic();
        return;
      }
      
      if (!supportsASR) return;
      
      startASR();
    });

    /* ============================================================
       Keyboard Shortcuts
       ============================================================ */
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        stopAll();
      }
    });

    /* ============================================================
       Backend Communication
       ============================================================ */
    async function safeJSON(res) {
      const txt = await res.text();
      try {
        return JSON.parse(txt);
      } catch (e) {
        console.error('JSON parse error:', e);
        throw new Error('Non-JSON response: ' + txt.slice(0, 120));
      }
    }

    async function callFunction(url, payload) {
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      
      if (!res.ok) {
        throw new Error(`${url} returned ${res.status}`);
      }
      
      return await safeJSON(res);
    }

    async function routeToBackend(text, opts = {}) {
      const payload = {
        text,
        message: text,
        sessionId: window.DTA.sessionId,
        context: getBoundedContext(),
        ...opts
      };

      try {
        const data = await callFunction('/.netlify/functions/session-chat', payload);
        await handleBackendResponse(data);
      } catch (e1) {
        console.warn('[DTA] session-chat failed, falling back to dop-chat:', e1);
        
        try {
          const data = await callFunction('/.netlify/functions/dop-chat', { text });
          await handleBackendResponse(data);
          showToast('Using fallback chat');
        } catch (e2) {
          console.error('[DTA] Both backends failed:', e2);
          srStatus.textContent = 'Backend error';
          setIdleUI();
          showToast('Backend error');
        }
      }
    }

    async function handleBackendResponse(data) {
      if (data.matchedClip) {
        setPlayingUI();
        playFile(data.matchedClip);
      } else if (data.fallbackResponse || data.reply) {
        setPlayingUI();
        const speech = data.fallbackResponse || data.reply;
        
        lastMode = 'tts';
        lastText = speech;

        pushTurn('assistant', speech, { audio: true });
        await speakWithElevenLabs(speech);
        setIdleUI();
      } else {
        console.warn('Unexpected backend response:', data);
        setIdleUI();
      }
    }

    /* ============================================================
       Text-to-Speech (ElevenLabs)
       ============================================================ */
    async function speakWithElevenLabs(text) {
      try {
        stopVideo();
        showOverlay();

        // Determine clip hint for voice selection
        let clipHint = null;
        if (window.DTA.lastPromptKey) {
          clipHint = window.DTA.lastPromptKey;
        } else if (lastFile && typeof lastFile === 'string') {
          clipHint = lastFile.replace(/^assets\//, '').replace(/\.mp4$/i, '').replace(/^p_/, '');
        }

        const res = await fetch('/.netlify/functions/tts-eleven', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text,
            clip: clipHint,
            voiceId: getSelectedVoiceId()
          })
        });

        if (!res.ok) {
          throw new Error('TTS request failed with status ' + res.status);
        }

        const buf = await res.arrayBuffer();
        const blob = new Blob([buf], { type: 'audio/mpeg' });
        const url = URL.createObjectURL(blob);
        
        currentAudioURL = url;
        currentAudio = new Audio(url);

        setPill('speaking', 'Speakingâ€¦');

        await currentAudio.play();
        await new Promise((resolve) => {
          currentAudio.addEventListener('ended', resolve, { once: true });
        });

      } catch (e) {
        console.warn('ElevenLabs TTS error, falling back to device TTS:', e);
        
        // Fallback to browser speech synthesis
        if ('speechSynthesis' in window) {
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.lang = 'en-US';
          setPill('speaking', 'Speakingâ€¦');
          
          try {
            speechSynthesis.cancel();
            speechSynthesis.speak(utterance);
            
            await new Promise((resolve) => {
              utterance.onend = resolve;
              setTimeout(resolve, TTS_FALLBACK_TIMEOUT_MS);
            });
          } catch (e2) {
            console.error('Fallback TTS also failed:', e2);
          }
        }
      } finally {
        hideOverlay();
        cleanupAudio();
      }
    }

    /* ============================================================
       Reset Button
       ============================================================ */
    resetBtn.addEventListener('click', resetSession);

    /* ============================================================
       Initialization
       ============================================================ */
    primeFirstFrame(currentFile);
    setTimeout(() => preloadSources(currentFile), 300);

    // Pre-warm TTS function to reduce first-utterance latency
    window.addEventListener('load', () => {
      fetch('/.netlify/functions/tts-eleven', { method: 'OPTIONS' })
        .catch(() => {
          // Silent fail - just a pre-warm attempt
        });
    });

    // Expose debug utilities
    window.DTA.reset = resetSession;
    window.DTA.getContext = getBoundedContext;

    console.log('[DTA] Initialized. Debug: window.DTA');
  </script>
</body>
</html>