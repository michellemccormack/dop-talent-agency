<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Dopple Talent Demo</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0e0f12; --bg-2:#08090c;
      --panel:#12131a; --panel-2:#1a1b25;
      --text:#ececf1; --muted:#b7b8c3;
      --stroke:#26283a; --stroke-strong:#3a3b52;
      --accent:#8a8cff;
      --ok:#16db65; --warn:#ffd166; --stop:#ff6b6b;
      --shadow:0 10px 30px rgba(0,0,0,.35); --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 80% -10%, rgba(94,97,255,.12), transparent 40%),
        radial-gradient(900px 480px at 0% 110%, rgba(138,140,255,.10), transparent 45%),
        linear-gradient(180deg,var(--bg),var(--bg-2));
      min-height:100vh;
    }

    /* Layout */
    .wrap{max-width:1100px; margin:0 auto; padding:28px 20px 48px}
    .card{
      position:relative;
      background:linear-gradient(180deg,var(--panel),var(--panel-2));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:26px 22px 32px;
      margin:18px 0;
    }
    .section{max-width:980px; margin:0 auto}
    .stack-s{margin-top:8px}
    .stack-m{margin-top:16px}
    .stack-l{margin-top:24px}
    .stack-xl{margin-top:32px}

    /* Reset Session button */
    .reset{
      position:absolute; right:18px; top:18px;
      appearance:none; border:1px solid var(--stroke-strong);
      background:#191a23; color:#cfd0dc; font-size:12px;
      border-radius:12px; padding:8px 10px; cursor:pointer;
    }
    .reset:hover{filter:brightness(1.05)}

    /* BIG mic button */
    .mic-rail{display:flex; justify-content:center}
    .mic{
      appearance:none; border:none; cursor:pointer;
      padding:18px 26px; border-radius:18px;
      font-size:18px; line-height:1; letter-spacing:.4px;
      font-family:'Montserrat',sans-serif; font-weight:800; text-transform:uppercase;
      background:linear-gradient(180deg,#fff,#eee); color:#000;
      box-shadow:0 8px 20px rgba(0,0,0,.25);
      min-width:240px;
      transition:transform .15s ease, opacity .15s ease, background .15s ease;
    }
    .mic:hover{transform:translateY(-1px)}
    .mic:active{transform:translateY(0)}
    .mic.listening{background:linear-gradient(180deg,var(--warn),#ffdf8a)}
    .mic.stopping{background:linear-gradient(180deg,var(--stop),#ff8a8a); color:#000}
    .mic[disabled]{opacity:.45; cursor:not-allowed}

    /* Status pill */
    .status-rail{display:flex; justify-content:center}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      background:#191a23; border:1px solid var(--stroke-strong);
      color:#cfd0dc; border-radius:999px; padding:7px 12px;
      font-size:12px; letter-spacing:.2px;
      box-shadow:0 6px 16px rgba(0,0,0,.25);
    }
    .dot{width:8px; height:8px; border-radius:999px; background:#666}
    .pill.listening .dot{background:#f7c948}
    .pill.thinking  .dot{background:#8a8cff}
    .pill.speaking  .dot{background:#16db65}
    .pill.ready     .dot{background:#6f7284}

    /* Instructions */
    .instructions{
      text-align:center;
      font-family:'Montserrat',sans-serif; font-weight:800; text-transform:uppercase;
      color:#d8d9e3; letter-spacing:.4px; font-size:14px;
    }
    .instructions small{display:block; color:#bfc1cd; margin-top:6px; font-size:9px}

    /* Prompt buttons */
    .prompt-grid{
      display:flex; flex-wrap:wrap; justify-content:center;
      gap:12px 14px;
      margin:18px auto 36px;
      max-width:1000px;
      padding:0 6px;
    }
    .btn{
      appearance:none; border:none; cursor:pointer;
      padding:10px 14px;
      border-radius:16px; font-size:12px;
      font-family:'Montserrat',sans-serif; font-weight:700; text-transform:uppercase;
      background:linear-gradient(180deg,#fff,#efefef); color:#000;
      border:1px solid #e7e7e7;
      white-space:nowrap;
      transition:transform .15s ease, opacity .15s ease;
    }
    .btn:hover{transform:translateY(-1px)}
    .btn[disabled]{opacity:.45; cursor:not-allowed}
    .btn.active{background:linear-gradient(180deg,#e9ebff,#dfe1ff); border-color:#cfd1ff}

    /* Video */
    .hero{display:flex; justify-content:center; position:relative}
    #resp{
      width:min(100%,560px); aspect-ratio:9/16; max-height:70vh;
      border-radius:14px; background:#000;
      border:1px solid var(--stroke-strong);
      box-shadow:0 12px 32px rgba(0,0,0,.35);
      opacity:1; transition:opacity 320ms ease;
      cursor:pointer; outline:none;
    }
    #resp:focus-visible{box-shadow:0 0 0 3px var(--accent)}
    .fade-start{opacity:0}

    /* Buffering overlay */
    .overlay {
      position:absolute; inset:0; display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.18); border-radius:14px;
      pointer-events:none;
    }
    .overlay.show{display:flex}
    .spinner{
      width:38px; height:38px; border-radius:999px;
      border:3px solid rgba(255,255,255,.35);
      border-top-color:#fff; animation:spin 900ms linear infinite;
      box-shadow:0 0 18px rgba(255,255,255,.25);
    }
    @keyframes spin{to{transform:rotate(360deg)}}

    .footer{font-size:12px; color:#b7b8c3; text-align:center; margin-top:26px; margin-bottom:60px}

    /* Toast */
    .toast{
      position:absolute; left:50%; bottom:20px; transform:translateX(-50%);
      background:#1b1c25; color:#eaeaf1; border:1px solid var(--stroke-strong);
      padding:10px 14px; border-radius:12px; box-shadow:var(--shadow);
      font-size:12px; letter-spacing:.2px;
      opacity:0; pointer-events:none; transition:opacity .20s ease;
    }
    .toast.show{opacity:1}

    /* SR-only */
    .sr-only{
      position:absolute !important; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); border:0;
    }

    @media (max-width:480px){
      .mic{min-width:195px; font-size:16px; padding:16px 22px}
      .btn{width:100%}
      #resp{max-height:68vh}
      .prompt-grid{gap:10px 12px; margin:14px auto 26px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card section">
      <!-- Reset Session (Tier 1 memory) -->
      <button class="reset" id="resetBtn" type="button" title="Reset session (clears local memory)">Reset Session</button>

      <!-- BIG mic button -->
      <div class="mic-rail">
        <button class="mic" id="micBtn" aria-pressed="false">ðŸŽ¤ Tap to Talk</button>
      </div>

      <!-- status pill -->
      <div class="status-rail stack-s">
        <div id="statusPill" class="pill ready" aria-live="polite">
          <span class="dot"></span><span id="pillText">Ready</span>
        </div>
      </div>

      <!-- instructions -->
      <div class="instructions stack-l">
        Ask Sasha one of these 3 questions.
        <small>If your microphone doesnâ€™t work, tap the question.</small>
      </div>

      <!-- prompt buttons -->
      <div class="prompt-grid stack-m" id="promptGrid">
        <button class="btn" data-file="assets/p_fun.mp4">What do you like to do for fun?</button>
        <button class="btn" data-file="assets/p_from.mp4">Where are you from?</button>
        <button class="btn" data-file="assets/p_relax.mp4">Whatâ€™s your favorite way to relax?</button>
      </div>

      <!-- response video + overlay -->
      <div class="hero">
        <video id="resp" playsinline preload="auto" tabindex="0" aria-label="Response video (tap to play or pause)"></video>
        <div id="overlay" class="overlay" aria-hidden="true"><div class="spinner"></div></div>
      </div>

      <!-- screen-reader-only status -->
      <div class="sr-only" aria-live="polite" id="asrStatus">Idle</div>

      <div class="footer">
        AI built by Michelle McCormack Â·
        <span id="memInfo">Session memory: Local (Tier 1). Context window capped to last 10 turns.</span>
      </div>

      <!-- Toast -->
      <div id="toast" class="toast" role="status" aria-live="polite"></div>
    </div>
  </div>

  <script>
    /* ============================================================
       Tier 1 Session Memory (Local) â€” baseline preserved
       ============================================================ */
    const MAX_TURNS = 10;
    const STREAM_ENDPOINT = "/.netlify/functions/stream-chat";

    const CLIP_META = {
      "assets/p_fun.mp4": {
        transcript: "Iâ€™m a go-out girlâ€”coffee walks, thrifting, and a little dancing never hurt. ðŸ˜‰"
      },
      "assets/p_from.mp4": {
        transcript: "Iâ€™m East-coast raised with a Boston edgeâ€”but Iâ€™ve bounced around enough to pick up good pizza opinions."
      },
      "assets/p_relax.mp4": {
        transcript: "Headphones on, hot shower, then a cozy movie night. Zero drama, maximum exhale."
      }
    };

    let sessionId = randId();
    /** @type {{role:'user'|'assistant'|'system', content:string, ts:number, meta?:any}[]} */
    const conversationHistory = [];

    function randId(len=12){
      const chars='abcdefghijklmnopqrstuvwxyz0123456789';
      let out=''; for(let i=0;i<len;i++) out+=chars[Math.floor(Math.random()*chars.length)];
      return out;
    }
    function pushTurn(role, content, meta){
      conversationHistory.push({ role, content: String(content||''), ts:Date.now(), meta: meta||{} });
      if (conversationHistory.length > MAX_TURNS) {
        conversationHistory.splice(0, conversationHistory.length - MAX_TURNS);
      }
    }

    // Toast helpers
    const toastEl = document.getElementById('toast');
    let toastTimer = null;
    function showToast(msg){
      if (!toastEl) return;
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => toastEl.classList.remove('show'), 1500);
    }

    function resetSession(){
      conversationHistory.length = 0;
      sessionId = randId();
      stopAll();
      setIdleUI();
      console.log('[DTA] Session reset â†’', sessionId);
      showToast('Session reset');
    }
    function getBoundedContext(){
      const system = { role:'system', content:'You are Sasha â€” be brief, warm, playful. Respect boundaries.' };
      return [system, ...conversationHistory.slice(-MAX_TURNS)];
    }
    window.DTA_reset = resetSession;

    /* ---------- Elements & state (baseline) ---------- */
    const resp = document.getElementById('resp');
    const grid = document.getElementById('promptGrid');
    const promptButtons = Array.from(grid.querySelectorAll('.btn'));
    const micBtn  = document.getElementById('micBtn');
    const srStatus = document.getElementById('asrStatus');
    const pill = document.getElementById('statusPill');
    const pillText = document.getElementById('pillText');
    const overlay = document.getElementById('overlay');
    const resetBtn = document.getElementById('resetBtn');
    const memInfo = document.getElementById('memInfo');

    let currentFile = 'assets/p_fun.mp4';
    let isStopped = true;

    // audio state
    let currentAudio = null;
    let currentAudioURL = null;

    // replay memory
    let lastMode = null;  // 'video' | 'tts'
    let lastFile = null;
    let lastText = null;

    // mic debounce
    let micLocked = false;
    function lockMic(ms=350){ micLocked = true; setTimeout(()=>micLocked=false, ms); }

    // simple in-memory video preload cache
    const preloadCache = new Map(); // src => HTMLVideoElement

    function haptic(ms=12){ if (navigator.vibrate) try{ navigator.vibrate(ms);}catch{} }

    /* ---------- Helpers (baseline) ---------- */
    function setPill(mode, text){
      pill.classList.remove('listening','thinking','speaking','ready');
      pill.classList.add(mode);
      pillText.textContent = text;
    }
    function showOverlay(){ overlay.classList.add('show'); }
    function hideOverlay(){ overlay.classList.remove('show'); }

    function primeFirstFrame(src){
      showOverlay();
      resp.classList.add('fade-start');
      resp.src = src;
      resp.load();
      resp.addEventListener('loadeddata', () => {
        resp.pause();
        resp.currentTime = 0;
        requestAnimationFrame(() => resp.classList.remove('fade-start'));
        isStopped = true;
        hideOverlay();
        setPill('ready','Ready');
      }, { once:true });
    }
    function safePlay(){
      const p = resp.play();
      if (p && typeof p.catch === 'function') p.catch(()=>{});
    }
    function clearActive(){ promptButtons.forEach(b => b.classList.remove('active')); }
    function setActiveByFile(file){
      clearActive();
      const btn = promptButtons.find(b => b.dataset.file === file);
      if (btn) btn.classList.add('active');
    }
    function disablePrompts(disabled){ promptButtons.forEach(b => b.disabled = !!disabled); }

    function stopAudio(){
      try {
        if (currentAudio) { currentAudio.pause(); currentAudio.src = ''; }
        if (currentAudioURL) { URL.revokeObjectURL(currentAudioURL); }
      } catch {}
      currentAudio = null;
      currentAudioURL = null;
      if ('speechSynthesis' in window) { try { speechSynthesis.cancel(); } catch{} }
    }

    function stopVideo(){
      resp.pause();
      resp.currentTime = 0;
      isStopped = true;
      clearActive();
    }

    /* ---------- UI states (baseline) ---------- */
    function setListeningUI(){
      micBtn.textContent = 'â–  Stop';
      micBtn.classList.add('listening');
      micBtn.classList.remove('stopping');
      micBtn.setAttribute('aria-pressed','true');
      disablePrompts(true);
      setPill('listening','Listeningâ€¦');
    }
    function setPlayingUI(){
      micBtn.textContent = 'â–  Stop';
      micBtn.classList.add('stopping');
      micBtn.classList.remove('listening');
      micBtn.setAttribute('aria-pressed','true');
      disablePrompts(true);
      setPill('speaking','Speakingâ€¦');
    }
    function setIdleUI(){
      micBtn.textContent = 'ðŸŽ¤ Tap to Talk';
      micBtn.classList.remove('listening','stopping');
      micBtn.setAttribute('aria-pressed','false');
      disablePrompts(false);
      srStatus.textContent = 'Idle';
      setPill('ready','Ready');
    }

    function stopAll(){
      stopAudio();
      stopVideo();
      setIdleUI();
      haptic();
    }

    /* ---------- Video preload (baseline) ---------- */
    function preloadSources(initialSrc){
      const uniqueSrcs = [...new Set(promptButtons.map(b => b.dataset.file))];
      uniqueSrcs.forEach(src => {
        if (src === initialSrc) return;
        if (preloadCache.has(src)) return;
        const v = document.createElement('video');
        v.preload = 'auto';
        v.src = src;
        v.addEventListener('loadeddata', ()=>{/* cached */}, { once:true });
        try { v.load(); } catch {}
        preloadCache.set(src, v);
      });
    }

    /* ---------- Video playback (baseline + memory hooks) ---------- */
    function playFile(file){
      stopAudio();

      const labelBtn = promptButtons.find(b => b.dataset.file === file);
      if (labelBtn){
        pushTurn('user', labelBtn.textContent.trim(), { inputType:'prompt', file });
      } else {
        pushTurn('user', 'Clicked prompt', { inputType:'prompt', file });
      }

      if (!isStopped && currentFile === file && !resp.paused) {
        stopVideo();
        setIdleUI();
        hideOverlay();
        return;
      }

      currentFile = file; isStopped = false; setActiveByFile(file);
      setPlayingUI();
      showOverlay();

      lastMode = 'video';
      lastFile = file;
      lastText = null;

      resp.classList.add('fade-start');
      resp.src = file; resp.load();
      const onCanPlay = () => {
        const meta = CLIP_META[file] || {};
        const textForMemory = meta.transcript || `Playing clip: ${file.split('/').pop()}`;
        pushTurn('assistant', textForMemory, { videoUrl: file, clip: file });

        safePlay();
        requestAnimationFrame(() => resp.classList.remove('fade-start'));
        hideOverlay();
      };
      resp.addEventListener('canplay', onCanPlay, { once:true });

      if (window.innerWidth < 900) resp.scrollIntoView({ behavior:'smooth', block:'center' });
    }

    /* ---------- Events (baseline) ---------- */
    resp.addEventListener('click', () => {
      if (resp.paused) { safePlay(); isStopped = false; setPlayingUI(); }
      else { stopVideo(); setIdleUI(); hideOverlay(); }
    });
    grid.addEventListener('click', (e) => {
      const btn = e.target.closest('.btn'); if (!btn) return;
      playFile(btn.dataset.file);
    });
    resp.addEventListener('ended', () => { stopVideo(); setIdleUI(); });
    resp.addEventListener('error', () => { stopVideo(); setIdleUI(); hideOverlay(); });

    /* ---------- ASR + STREAM-CHAT (always) + ElevenLabs TTS ---------- */
    const supportsASR = ('SpeechRecognition' in window) || ('webkitSpeechRecognition' in window);
    let recognizer = null, recognizing = false, finalTranscript = '';

    if (!supportsASR) { micBtn.disabled = true; srStatus.textContent = 'Speech input not available.'; }

    function initRecognizer(){
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognizer = new SR();
      recognizer.lang = 'en-US';
      recognizer.interimResults = true;
      recognizer.continuous = false;

      recognizer.onstart = () => {
        recognizing = true; finalTranscript = '';
        stopAll();
        setListeningUI();
        srStatus.textContent = 'Listeningâ€¦';
        lockMic();
        haptic();
      };
      recognizer.onerror = (e) => { srStatus.textContent = 'Mic error: ' + (e.error || 'unknown'); stopASR(); setIdleUI(); hideOverlay(); };
      recognizer.onend = () => {
        recognizing = false;
        const text = finalTranscript.trim();
        if (text) {
          pushTurn('user', text, { inputType:'mic' });
          srStatus.textContent = 'Processingâ€¦';
          setPill('thinking','Thinkingâ€¦');
          // ALWAYS stream-chat for mic
          streamChatSSE(text);
        } else { setIdleUI(); }
      };
      recognizer.onresult = (event) => {
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          if (res.isFinal) finalTranscript += res[0].transcript.trim() + ' ';
        }
      };
    }
    function startASR(){ if (!recognizer) initRecognizer(); try { recognizer.start(); } catch { try { recognizer.stop(); recognizer.start(); } catch(_){} } }
    function stopASR(){ if (recognizer && recognizing) recognizer.stop(); recognizing = false; }

    micBtn.addEventListener('click', () => {
      if (micLocked) return;
      if (micBtn.textContent.includes('Stop')) { stopAll(); lockMic(); return; }
      if (!supportsASR) return;
      startASR();
    });
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape') stopAll(); });

    // ---- JSON helper (kept for fallback path) ----
    async function safeJSON(res){
      const txt = await res.text();
      try { return JSON.parse(txt); }
      catch { throw new Error('Non-JSON response: ' + txt.slice(0,120)); }
    }
    async function callFunction(url, payload){
      const res = await fetch(url, {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) throw new Error(`${url} ${res.status}`);
      return await safeJSON(res);
    }

    /* ============================================================
       SSE Streaming (mic path)
       ============================================================ */
    let currentEventSource = null;

    function streamChatSSE(userText){
      if (currentEventSource){ try { currentEventSource.close(); } catch(_){} currentEventSource = null; }

      setPill('thinking','Thinkingâ€¦');

      const qs = new URLSearchParams({
        sessionId,
        message: userText,
        persona: 'sasha'
      }).toString();

      const es = new EventSource(`${STREAM_ENDPOINT}?${qs}`);
      currentEventSource = es;

      let full = "";

      es.addEventListener('token', (evt) => {
        if (pill.classList.contains('thinking')) setPill('speaking','Speakingâ€¦');
        try{
          const { content } = JSON.parse(evt.data);
          if (content) full += content;
        }catch(_){}
      });

      es.addEventListener('done', async () => {
        try { es.close(); } catch(_){}
        currentEventSource = null;

        if (full.trim()){
          pushTurn('assistant', full.trim(), { streamed:true });
          setPlayingUI(); // keep pill in Speaking during audio
          await speakWithElevenLabs(full.trim());
        }
        setIdleUI();
      });

      es.addEventListener('error', async () => {
        try { es.close(); } catch(_){}
        currentEventSource = null;
        // Fallback to non-stream function chain
        try{
          const data = await callFunction('/.netlify/functions/session-chat', {
            text: userText, message: userText, sessionId, context: getBoundedContext(), forceLLM: true
          });
          await handleBackendResponse(data);
        }catch(e2){
          console.warn('[DTA] stream + session-chat failed; falling back â†’ dop-chat', e2);
          try{
            const data = await callFunction('/.netlify/functions/dop-chat', { text: userText });
            await handleBackendResponse(data);
            showToast('Using fallback chat');
          }catch(e3){
            console.error('[DTA] dop-chat also failed', e3);
            srStatus.textContent = 'Backend error';
            setIdleUI();
            showToast('Backend error');
          }
        }
      });
    }

    async function handleBackendResponse(data){
      if (data.matchedClip) {
        setPlayingUI();
        playFile(data.matchedClip);
      } else if (data.fallbackResponse || data.reply) {
        setPlayingUI();
        const speech = data.fallbackResponse || data.reply;
        lastMode = 'tts';
        lastText = speech;
        lastFile = null;

        pushTurn('assistant', speech, { audio:true });
        await speakWithElevenLabs(speech);
        setIdleUI();
      } else {
        setIdleUI();
      }
    }

    // TTS
    async function speakWithElevenLabs(text){
      try{
        stopVideo();
        showOverlay();

        const res = await fetch('/.netlify/functions/tts-eleven', {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify({ text })
        });
        if (!res.ok) throw new Error('TTS failed');

        const buf = await res.arrayBuffer();
        const blob = new Blob([buf], { type: 'audio/mpeg' });
        currentAudioURL = URL.createObjectURL(blob);
        currentAudio = new Audio(currentAudioURL);

        setPill('speaking','Speakingâ€¦');
        await currentAudio.play().catch(()=>{});
        await new Promise((resolve) => {
          const cleanup = () => { currentAudio && currentAudio.removeEventListener('ended', cleanup); resolve(); };
          currentAudio.addEventListener('ended', cleanup, { once:true });
        });
      } catch(e){
        console.warn('ElevenLabs TTS error, falling back to device TTS', e);
        if ('speechSynthesis' in window) {
          const u = new SpeechSynthesisUtterance(text);
          u.lang = 'en-US';
          setPill('speaking','Speakingâ€¦');
          try { speechSynthesis.cancel(); speechSynthesis.speak(u); } catch {}
          await new Promise((resolve) => { u.onend = resolve; setTimeout(resolve, 12000); });
        }
      } finally {
        hideOverlay();
        try{
          if (currentAudio) { currentAudio.pause(); currentAudio.src=''; }
          if (currentAudioURL) URL.revokeObjectURL(currentAudioURL);
        }catch{}
        currentAudio=null; currentAudioURL=null;
      }
    }

    // Reset button
    resetBtn.addEventListener('click', resetSession);

    // Boot
    primeFirstFrame(currentFile);
    setTimeout(() => preloadSources(currentFile), 300);

    // Debug tips in console:
    // conversationHistory, getBoundedContext(), DTA_reset()
  </script>
</body>
</html>
