<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Chat with DOP - Dopple Talent Agency</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0e0f12; --bg-2:#08090c;
      --panel:#12131a; --panel-2:#1a1b25;
      --text:#ececf1; --muted:#b7b8c3;
      --stroke:#26283a; --stroke-strong:#3a3b52;
      --accent:#8a8cff;
      --ok:#16db65; --warn:#ffd166; --stop:#ff6b6b;
      --shadow:0 10px 30px rgba(0,0,0,.35); --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 80% -10%, rgba(94,97,255,.12), transparent 40%),
        radial-gradient(900px 480px at 0% 110%, rgba(138,140,255,.10), transparent 45%),
        linear-gradient(180deg,var(--bg),var(--bg-2));
      min-height:100vh;
    }

    /* Layout */
    .wrap{max-width:1100px; margin:0 auto; padding:28px 20px 48px}
    .card{
      position:relative;
      background:linear-gradient(180deg,var(--panel),var(--panel-2));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:26px 22px 32px;
      margin:18px 0;
    }
    .section{max-width:980px; margin:0 auto}
    .stack-s{margin-top:8px}
    .stack-m{margin-top:16px}
    .stack-l{margin-top:24px}
    .stack-xl{margin-top:32px}

    /* Reset Session button */
    .reset{
      position:absolute; right:18px; top:18px;
      appearance:none; border:1px solid var(--stroke-strong);
      background:#191a23; color:#cfd0dc; font-size:12px;
      border-radius:12px; padding:8px 10px; cursor:pointer;
    }
    .reset:hover{filter:brightness(1.05)}

    /* BIG mic button */
    .mic-rail{display:flex; justify-content:center}
    .mic{
      appearance:none; border:none; cursor:pointer;
      padding:18px 26px; border-radius:18px;
      font-size:18px; line-height:1; letter-spacing:.4px;
      font-family:'Montserrat',sans-serif; font-weight:800; text-transform:uppercase;
      background:linear-gradient(180deg,#fff,#eee); color:#000;
      box-shadow:0 8px 20px rgba(0,0,0,.25);
      min-width:240px;
      transition:transform .15s ease, opacity .15s ease, background .15s ease;
    }
    .mic:hover{transform:translateY(-1px)}
    .mic:active{transform:translateY(0)}
    .mic.listening{background:linear-gradient(180deg,var(--warn),#ffdf8a)}
    .mic.stopping{background:linear-gradient(180deg,var(--stop),#ff8a8a); color:#000}
    .mic[disabled]{opacity:.45; cursor:not-allowed}

    /* Status pill */
    .status-rail{display:flex; justify-content:center}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      background:#191a23; border:1px solid var(--stroke-strong);
      color:#cfd0dc; border-radius:999px; padding:7px 12px;
      font-size:12px; letter-spacing:.2px;
      box-shadow:0 6px 16px rgba(0,0,0,.25);
    }
    .dot{width:8px; height:8px; border-radius:999px; background:#666}
    .pill.listening .dot{background:#f7c948}
    .pill.thinking  .dot{background:#8a8cff}
    .pill.speaking  .dot{background:#16db65}
    .pill.ready     .dot{background:#6f7284}

    /* Instructions */
    .instructions{
      text-align:center;
      font-family:'Montserrat',sans-serif; font-weight:800; text-transform:uppercase;
      color:#d8d9e3; letter-spacing:.4px; font-size:14px;
    }
    .instructions small{display:block; color:#bfc1cd; margin-top:6px; font-size:9px}

    /* Prompt buttons */
    .prompt-grid{
      display:flex; flex-wrap:wrap; justify-content:center;
      gap:12px 14px;
      margin:18px auto 36px;
      max-width:1000px;
      padding:0 6px;
    }
    .btn{
      appearance:none; border:none; cursor:pointer;
      padding:10px 14px;
      border-radius:16px; font-size:12px;
      font-family:'Montserrat',sans-serif; font-weight:700; text-transform:uppercase;
      background:linear-gradient(180deg,#fff,#efefef); color:#000;
      border:1px solid #e7e7e7;
      white-space:nowrap;
      transition:transform .15s ease, opacity .15s ease;
    }
    .btn:hover{transform:translateY(-1px)}
    .btn[disabled]{opacity:.45; cursor:not-allowed}
    .btn.active{background:linear-gradient(180deg,#e9ebff,#dfe1ff); border-color:#cfd1ff}

    /* Video */
    .hero{display:flex; justify-content:center; position:relative}
    #resp, .dop-image{
      width:min(100%,560px); aspect-ratio:9/16; max-height:70vh;
      border-radius:14px; background:#000;
      border:1px solid var(--stroke-strong);
      box-shadow:0 12px 32px rgba(0,0,0,.35);
      opacity:1; transition:opacity 320ms ease;
      cursor:pointer; outline:none;
      object-fit:cover;
    }
    .dop-image{display:none} /* Hidden by default, shown for user DOPs */
    #resp:focus-visible{box-shadow:0 0 0 3px var(--accent)}
    .fade-start{opacity:0}

    /* Buffering overlay */
    .overlay {
      position:absolute; inset:0; display:none;
      align-items:center; justify-content:center;
      background:rgba(0,0,0,.18); border-radius:14px;
      pointer-events:none;
    }
    .overlay.show{display:flex}
    .spinner{
      width:38px; height:38px; border-radius:999px;
      border:3px solid rgba(255,255,255,.35);
      border-top-color:#fff; animation:spin 900ms linear infinite;
      box-shadow:0 0 18px rgba(255,255,255,.25);
    }
    @keyframes spin{to{transform:rotate(360deg)}}

    .footer{font-size:12px; color:#b7b8c3; text-align:center; margin-top:26px; margin-bottom:60px}

    /* Toast */
    .toast{
      position:absolute; left:50%; bottom:20px; transform:translateX(-50%);
      background:#1b1c25; color:#eaeaf1; border:1px solid var(--stroke-strong);
      padding:10px 14px; border-radius:12px; box-shadow:var(--shadow);
      font-size:12px; letter-spacing:.2px;
      opacity:0; pointer-events:none; transition:opacity .20s ease;
    }
    .toast.show{opacity:1}

    /* SR-only */
    .sr-only{
      position:absolute !important; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); border:0;
    }

    /* DOP Header */
    .dop-header{
      display:flex; align-items:center; gap:16px; margin-bottom:24px;
      padding:16px 0; border-bottom:1px solid var(--stroke);
    }
    .dop-avatar{
      width:50px; height:50px; border-radius:50%;
      background:var(--stroke); object-fit:cover;
      border:2px solid var(--stroke-strong);
    }
    .dop-info h1{
      margin:0; font-size:1.5rem; font-weight:700;
      font-family:'Montserrat',sans-serif;
    }
    .dop-info p{margin:4px 0 0; color:var(--muted); font-size:14px}

    /* Loading state */
    .loading-state{
      text-align:center; padding:60px 20px; color:var(--muted);
    }
    .loading-state .spinner{margin:0 auto 20px}
    .error-state{
      text-align:center; padding:40px; color:var(--stop);
    }
    .error-state .details{font-size:12px; margin-top:8px; color:var(--muted)}

    @media (max-width:480px){
      .dop-header{flex-direction:column; text-align:center}
      .mic{min-width:195px; font-size:16px; padding:16px 22px}
      .btn{width:100%}
      #resp, .dop-image{max-height:68vh}
      .prompt-grid{gap:10px 12px; margin:14px auto 26px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card section">
      <!-- Loading state -->
      <div class="loading-state" id="loadingState">
        <div class="spinner"></div>
        <div>Loading your DOP...</div>
      </div>

      <!-- Error state -->
      <div class="error-state" id="errorState" style="display:none">
        <div>Sorry, this DOP couldn't be loaded.</div>
        <div class="details" id="errorDetails"></div>
      </div>

      <!-- Main interface (hidden until loaded) -->
      <div id="mainInterface" style="display:none">
        <!-- DOP Header (only shown for user DOPs) -->
        <div class="dop-header" id="dopHeader" style="display:none">
          <img class="dop-avatar" id="dopAvatar" alt="DOP Avatar" />
          <div class="dop-info">
            <h1 id="dopName">Loading...</h1>
            <p id="dopBio">Loading personality...</p>
          </div>
        </div>
        <!-- Reset Session (Tier 1 memory) -->
        <button class="reset" id="resetBtn" type="button" title="Reset session (clears local memory)">Reset Session</button>

        <!-- BIG mic button -->
        <div class="mic-rail">
          <button class="mic" id="micBtn" aria-pressed="false">ðŸŽ¤ Tap to Talk</button>
        </div>

        <!-- status pill -->
        <div class="status-rail stack-s">
          <div id="statusPill" class="pill ready" aria-live="polite">
            <span class="dot"></span><span id="pillText">Ready</span>
          </div>
        </div>

        <!-- instructions -->
        <div class="instructions stack-l">
          <span id="dopNameDisplay">Ask one of these questions.</span>
          <small>If your microphone doesn't work, tap the question.</small>
        </div>

        <!-- prompt buttons -->
        <div class="prompt-grid stack-m" id="promptGrid">
          <!-- Dynamically populated -->
        </div>

        <!-- response video + overlay -->
        <div class="hero">
          <video id="resp" playsinline preload="auto" tabindex="0" aria-label="Response video (tap to play or pause)"></video>
          <img class="dop-image" id="dopImage" alt="DOP" />
          <div class="overlay" id="respOverlay"><div class="spinner"></div></div>
        </div>
      </div>
    </div>
  </div>

  <!-- SR-only status for screen readers -->
  <div id="srStatus" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

  <script>
    // ===== DYNAMIC PERSONA LOADING =====
    const urlParams = new URLSearchParams(window.location.search);
    const dopId = urlParams.get('id');
    
    let PERSONA_DATA = null;
    let PROMPTS_CONFIG = [];

    // Load persona on startup
    async function loadPersona() {
      const loadingState = document.getElementById('loadingState');
      const errorState = document.getElementById('errorState');
      const errorDetails = document.getElementById('errorDetails');
      const mainInterface = document.getElementById('mainInterface');
      const dopHeader = document.getElementById('dopHeader');
      const dopName = document.getElementById('dopName');
      const dopBio = document.getElementById('dopBio');
      const dopAvatar = document.getElementById('dopAvatar');
      const dopImage = document.getElementById('dopImage');
      const resp = document.getElementById('resp');

      try {
        if (!dopId) {
          // No ID - use default Sasha persona
          console.log('[chat] No DOP ID, using default persona');
          PERSONA_DATA = {
            name: 'Sasha',
            prompts: [
              'What do you like to do for fun?',
              'Where are you from?',
              "What's your favorite way to relax?"
            ]
          };
          PROMPTS_CONFIG = [
            { question: 'What do you like to do for fun?', file: 'assets/p_fun.mp4' },
            { question: 'Where are you from?', file: 'assets/p_from.mp4' },
            { question: "What's your favorite way to relax?", file: 'assets/p_relax.mp4' }
          ];
          
          // Show video element for default persona
          resp.style.display = 'block';
          dopImage.style.display = 'none';
        } else {
          // Load persona from backend
          console.log('[chat] Loading DOP:', dopId);
          const response = await fetch(`/.netlify/functions/dop-persona?id=${encodeURIComponent(dopId)}`);
          
          if (!response.ok) {
            throw new Error(`Failed to load DOP: ${response.status}`);
          }

          PERSONA_DATA = await response.json();
          console.log('[chat] Persona loaded:', PERSONA_DATA);

          // Build prompts config (for user-generated DOPs, we don't have video files yet)
          PROMPTS_CONFIG = (PERSONA_DATA.prompts || []).map(prompt => ({
            question: prompt,
            file: null // No pre-recorded videos for user DOPs yet
          }));

          // Show DOP header for user-generated DOPs
          dopHeader.style.display = 'flex';
          dopName.textContent = PERSONA_DATA.name || 'DOP';
          dopBio.textContent = PERSONA_DATA.bio || 'Your AI doppelgÃ¤nger';

          // Set avatar and main image using base64 data
          if (PERSONA_DATA.image) {
            const imageUrl = PERSONA_DATA.image.startsWith('data:') 
              ? PERSONA_DATA.image 
              : `data:image/jpeg;base64,${PERSONA_DATA.image}`;
            
            console.log('[chat] Setting image URL (first 100 chars):', imageUrl.substring(0, 100));
            dopAvatar.src = imageUrl;
            dopImage.src = imageUrl;
            
            // Add error handler
            dopImage.onerror = () => {
              console.error('[chat] Image failed to load');
            };
            dopImage.onload = () => {
              console.log('[chat] Image loaded successfully');
            };
            
            // Show image, hide video for user DOPs
            resp.style.display = 'none';
            dopImage.style.display = 'block';
            console.log('[chat] Image display set to block, video hidden');
          } else {
            console.log('[chat] No image data found in persona');
          }
        }

        // Update UI
        document.getElementById('dopNameDisplay').textContent = 
          `Ask ${PERSONA_DATA.name || 'DOP'} one of these questions.`;

        // Create prompt buttons
        const grid = document.getElementById('promptGrid');
        grid.innerHTML = PROMPTS_CONFIG.map((p, i) => 
          `<button class="btn" data-index="${i}">${p.question}</button>`
        ).join('');

        // Show interface
        loadingState.style.display = 'none';
        mainInterface.style.display = 'block';

        // Initialize the rest of the app
        initializeApp();

      } catch (error) {
        console.error('[chat] Failed to load persona:', error);
        loadingState.style.display = 'none';
        errorState.style.display = 'block';
        errorDetails.textContent = error.message;
      }
    }

    // Start loading
    loadPersona();

    // ===== REST OF THE WORKING CODE FROM INDEX.HTML =====
    function initializeApp() {
      const resp = document.getElementById('resp');
      const respOverlay = document.getElementById('respOverlay');
      const micBtn = document.getElementById('micBtn');
      const resetBtn = document.getElementById('resetBtn');
      const statusPill = document.getElementById('statusPill');
      const pillText = document.getElementById('pillText');
      const srStatus = document.getElementById('srStatus');
      const grid = document.getElementById('promptGrid');

      // Session
      let sessionId = 'sess_' + Date.now() + '_' + Math.random().toString(36).slice(2,9);
      let conversationHistory = [];
      const MAX_CONTEXT = 8;

      function pushTurn(role, content, meta={}){
        conversationHistory.push({ role, content, ...meta });
        if (conversationHistory.length > MAX_CONTEXT*2) {
          conversationHistory.splice(0, conversationHistory.length - MAX_CONTEXT*2);
        }
      }
      function getBoundedContext(){
        return conversationHistory.slice(-MAX_CONTEXT*2).map(t => ({ role:t.role, content:t.content }));
      }
      function resetSession(){
        if (confirm('Reset conversation memory?')) {
          conversationHistory = [];
          sessionId = 'sess_' + Date.now() + '_' + Math.random().toString(36).slice(2,9);
          stopAll();
          setIdleUI();
          showToast('Session reset');
        }
      }
      window.DTA_reset = resetSession;

      // State
      let currentFile = null, lastFile = null, lastMode = null, lastText = '';
      let isStopped = false, micLocked = false;
      let currentAudio = null, currentAudioURL = null;

      function haptic(){ if ('vibrate' in navigator) navigator.vibrate(60); }
      function lockMic(){ micLocked = true; setTimeout(() => micLocked = false, 350); }
      function showOverlay(){ respOverlay.classList.add('show'); }
      function hideOverlay(){ respOverlay.classList.remove('show'); }
      function showToast(msg){ const t = document.createElement('div'); t.className='toast show'; t.textContent=msg; document.body.append(t); setTimeout(() => { t.classList.remove('show'); setTimeout(() => t.remove(), 250); }, 2000); }

      function setPill(mode, text){
        statusPill.classList.remove('listening','thinking','speaking','ready');
        statusPill.classList.add(mode);
        pillText.textContent = text;
        srStatus.textContent = text;
      }
      function setListeningUI(){ micBtn.classList.add('listening'); micBtn.textContent = 'â¹ Stop'; setPill('listening','Listeningâ€¦'); }
      function setThinkingUI(){ micBtn.classList.remove('listening','stopping'); micBtn.textContent = 'ðŸŽ¤ Tap to Talk'; setPill('thinking','Thinkingâ€¦'); }
      function setPlayingUI(){ micBtn.classList.remove('listening','stopping'); micBtn.textContent = 'ðŸŽ¤ Tap to Talk'; setPill('speaking','Speakingâ€¦'); }
      function setIdleUI(){ micBtn.classList.remove('listening','stopping'); micBtn.textContent = 'ðŸŽ¤ Tap to Talk'; setPill('ready','Ready'); }

      function stopAll(){
        stopVideo();
        stopASR();
        stopAudio();
        setIdleUI();
        hideOverlay();
      }
      function stopVideo(){ if (resp && !resp.paused) resp.pause(); isStopped = true; }
      function stopAudio(){ if (currentAudio) { currentAudio.pause(); currentAudio.src=''; } if (currentAudioURL) URL.revokeObjectURL(currentAudioURL); currentAudio=null; currentAudioURL=null; }

      function safePlay(){ try { resp.play().catch(e => { console.warn('Autoplay blocked:',e); showToast('Tap video to play'); }); } catch{} }

      // Voice mapping logic
      window.DOP_LAST_PROMPT = null;
      function getVoiceIdForNextTTS(){
        if (!PERSONA_DATA.voiceId) return null;
        return PERSONA_DATA.voiceId;
      }
      function setVoiceForNextTTSByFile(file){ 
        if (!file) return;
        const key = file.replace(/^assets\//,'').replace(/\.mp4$/i,'');
        window.DOP_LAST_PROMPT = key;
      }
      function forceFallbackVoiceForMic(){ if (!window.DOP_LAST_PROMPT) window.DOP_LAST_PROMPT = 'fallback'; }

      // Video player
      function preloadSources(firstFile){
        if (!firstFile) return;
        // Preload video files if they exist
        setTimeout(() => {
          PROMPTS_CONFIG.forEach(p => {
            if (p.file) {
              const v = document.createElement('video');
              v.src = p.file; v.preload = 'auto'; v.load();
            }
          });
        }, 100);
      }
      function primeFirstFrame(file){
        if (!file || !resp) return;
        resp.src = file;
        resp.classList.add('fade-start');
        resp.load();
        setTimeout(() => { resp.currentTime = 0.1; resp.classList.remove('fade-start'); }, 80);
      }

      function playFile(file){
        if (!file) return;
        console.log('Playing file:', file);
        currentFile = file;
        lastFile = file;
        lastMode = 'clip';
        lastText = '';
        isStopped = false;

        stopAll();
        setPlayingUI();
        showOverlay();

        pushTurn('user', findQuestionForFile(file), { inputType:'button' });

        resp.src = file;
        resp.load();
        resp.onloadeddata = () => {
          hideOverlay();
          safePlay();
          const transcript = findTranscriptForFile(file);
          if (transcript) pushTurn('assistant', transcript, { audio:false, video:file });
        };
        resp.onerror = () => { hideOverlay(); setIdleUI(); };
      }

      function findQuestionForFile(file){
        const match = PROMPTS_CONFIG.find(p => p.file === file);
        return match ? match.question : '';
      }
      function findTranscriptForFile(file){
        const match = PROMPTS_CONFIG.find(p => p.file === file);
        return match ? match.response || '' : '';
      }

      // Events
      resp.addEventListener('click', () => {
        if (resp.paused) { safePlay(); isStopped = false; setPlayingUI(); }
        else { stopVideo(); setIdleUI(); hideOverlay(); }
      });

      grid.addEventListener('click', (e) => {
        const btn = e.target.closest('.btn');
        if (!btn) return;
        
        const index = parseInt(btn.dataset.index);
        const promptConfig = PROMPTS_CONFIG[index];
        
        if (promptConfig.file) {
          // Pre-recorded video exists
          setVoiceForNextTTSByFile(promptConfig.file);
          playFile(promptConfig.file);
        } else {
          // No video - use LLM + TTS
          const question = promptConfig.question;
          pushTurn('user', question, { inputType:'button' });
          setPill('thinking','Thinkingâ€¦');
          routeToBackend(question, { forceLLM: true });
        }
      });

      resp.addEventListener('ended', () => { stopVideo(); setIdleUI(); });
      resp.addEventListener('error', () => { stopVideo(); setIdleUI(); hideOverlay(); });

      // ASR + backend routing + ElevenLabs TTS
      const supportsASR = ('SpeechRecognition' in window) || ('webkitSpeechRecognition' in window);
      let recognizer = null, recognizing = false, finalTranscript = '';
      let asrFinalSent = false;

      if (!supportsASR) { micBtn.disabled = true; srStatus.textContent = 'Speech input not available.'; }

      function initRecognizer(){
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognizer = new SR();
        recognizer.lang = 'en-US';
        recognizer.interimResults = true;
        recognizer.continuous = false;

        recognizer.onstart = () => {
          recognizing = true; finalTranscript = ''; asrFinalSent = false;
          stopAll();
          setListeningUI();
          srStatus.textContent = 'Listeningâ€¦';
          lockMic();
          haptic();
          forceFallbackVoiceForMic();
        };
        recognizer.onerror = (e) => { srStatus.textContent = 'Mic error: ' + (e.error || 'unknown'); stopASR(); setIdleUI(); hideOverlay(); };
        recognizer.onend = () => {
          recognizing = false;
          if (!asrFinalSent) setIdleUI();
        };
        recognizer.onresult = (event) => {
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const res = event.results[i];
            if (res.isFinal) {
              finalTranscript += res[0].transcript.trim() + ' ';
              if (!asrFinalSent) {
                asrFinalSent = true;
                const text = finalTranscript.trim();
                if (text) {
                  try { stopASR(); } catch {}
                  pushTurn('user', text, { inputType:'mic' });
                  srStatus.textContent = 'Processingâ€¦';
                  setPill('thinking','Thinkingâ€¦');
                  routeToBackend(text, { forceLLM: true });
                }
              }
            }
          }
        };
      }
      function startASR(){ if (!recognizer) initRecognizer(); try { recognizer.start(); } catch { try { recognizer.stop(); recognizer.start(); } catch(_){} } }
      function stopASR(){ if (recognizer && recognizing) recognizer.stop(); recognizing = false; }

      micBtn.addEventListener('click', () => {
        if (micLocked) return;
        if (micBtn.textContent.includes('Stop')) { stopAll(); lockMic(); return; }
        if (!supportsASR) return;
        startASR();
      });
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') stopAll(); });

      // Helpers for JSON fetch
      async function safeJSON(res){
        const txt = await res.text();
        try { return JSON.parse(txt); }
        catch { throw new Error('Non-JSON response: ' + txt.slice(0,120)); }
      }
      async function callFunction(url, payload){
        const res = await fetch(url, {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error(`${url} ${res.status}`);
        return await safeJSON(res);
      }

      // NON-STREAM route only
      async function routeToBackend(text, opts = {}){
        const payload = { 
          text, 
          message: text, 
          sessionId, 
          context: getBoundedContext(),
          personaId: dopId,
          ...opts 
        };
        try{
          const data = await callFunction('/.netlify/functions/session-chat', payload);
          await handleBackendResponse(data);
        } catch (e1){
          console.warn('[DTA] session-chat failed, falling back â†’ dop-chat', e1);
          try{
            const data = await callFunction('/.netlify/functions/dop-chat', { text });
            await handleBackendResponse(data);
            showToast('Using fallback chat');
          } catch (e2){
            console.error('[DTA] dop-chat also failed', e2);
            srStatus.textContent = 'Backend error';
            setIdleUI();
            showToast('Backend error');
          }
        }
      }

      async function handleBackendResponse(data){
        if (data.matchedClip) {
          setPlayingUI();
          playFile(data.matchedClip);
        } else if (data.fallbackResponse || data.reply) {
          setPlayingUI();
          const speech = data.fallbackResponse || data.reply;
          lastMode = 'tts';
          lastText = speech;

          pushTurn('assistant', speech, { audio:true });
          await speakWithElevenLabs(speech);
          setIdleUI();
        } else {
          setIdleUI();
        }
      }

      // TTS â€” pass voice AND clip hint so server picks the right voice deterministically
      async function speakWithElevenLabs(text){
        try{
          stopVideo();
          showOverlay();

          // clip hint from lastFile (e.g., "assets/p_fun.mp4" -> "p_fun")
          let clipHint = null;
          if (lastFile && typeof lastFile === 'string') {
            clipHint = lastFile.replace(/^assets\//,'').replace(/\.mp4$/i,'');
          }
          // ADD-ONLY: if mic-only (no lastFile), reuse last prompt key
          if (!clipHint && window.DOP_LAST_PROMPT) {
            clipHint = window.DOP_LAST_PROMPT; // e.g., "p_fun"
          }

          const res = await fetch('/.netlify/functions/tts-eleven', {
            method:'POST',
            headers:{ 'Content-Type':'application/json' },
            body: JSON.stringify({
              text,
              clip: clipHint,
              voiceId: getVoiceIdForNextTTS()
            })
          });
          if (!res.ok) throw new Error('TTS failed');

          const buf = await res.arrayBuffer();
          const blob = new Blob([buf], { type: 'audio/mpeg' });
          const url = URL.createObjectURL(blob);
          currentAudioURL = url;
          currentAudio = new Audio(url);

          setPill('speaking','Speakingâ€¦');
          await currentAudio.play().catch(()=>{});
          await new Promise((resolve) => {
            const cleanup = () => { currentAudio && currentAudio.removeEventListener('ended', cleanup); resolve(); };
            currentAudio.addEventListener('ended', cleanup, { once:true });
          });
        } catch(e){
          console.warn('ElevenLabs TTS error, falling back to device TTS', e);
          if ('speechSynthesis' in window) {
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'en-US';
            setPill('speaking','Speakingâ€¦');
            try { speechSynthesis.cancel(); speechSynthesis.speak(u); } catch {}
            await new Promise((resolve) => { u.onend = resolve; setTimeout(resolve, 12000); });
          }
        } finally {
          hideOverlay();
          try{
            if (currentAudio) { currentAudio.pause(); currentAudio.src=''; }
            if (currentAudioURL) URL.revokeObjectURL(currentAudioURL);
          }catch{}
          currentAudio=null; currentAudioURL=null;
        }
      }

      // Reset button
      resetBtn.addEventListener('click', resetSession);

      // Boot
      const firstPrompt = PROMPTS_CONFIG[0];
      if (firstPrompt && firstPrompt.file) {
        primeFirstFrame(firstPrompt.file);
        setTimeout(() => preloadSources(firstPrompt.file), 300);
      }

      // Pre-warm TTS function to cut first-utterance latency
      window.addEventListener('load', () => {
        fetch('/.netlify/functions/tts-eleven', { method:'OPTIONS' }).catch(()=>{});
      });

      // Debug tips in console:
      console.log('Debug: conversationHistory, getBoundedContext(), DTA_reset()');
    }
  </script>
</body>
</html>