<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Chat with DOP - Dopple Talent Agency</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0e0f12; --bg-2:#08090c;
      --panel:#12131a; --panel-2:#1a1b25;
      --text:#ececf1; --muted:#b7b8c3;
      --stroke:#26283a; --stroke-strong:#3a3b52;
      --accent:#8a8cff;
      --ok:#16db65; --warn:#ffd166; --stop:#ff6b6b;
      --shadow:0 10px 30px rgba(0,0,0,.35); --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 80% -10%, rgba(94,97,255,.12), transparent 40%),
        radial-gradient(900px 480px at 0% 110%, rgba(138,140,255,.10), transparent 45%),
        linear-gradient(180deg,var(--bg),var(--bg-2));
      min-height:100vh;
    }

    .wrap{max-width:1100px; margin:0 auto; padding:28px 20px 48px}
    .card{
      position:relative;
      background:linear-gradient(180deg,var(--panel),var(--panel-2));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:26px 22px 32px;
      margin:18px 0;
    }
    .section{max-width:980px; margin:0 auto}
    .stack-s{margin-top:8px}
    .stack-m{margin-top:16px}
    .stack-l{margin-top:24px}
    .stack-xl{margin-top:32px}

    .reset{
      position:absolute; right:18px; top:18px;
      appearance:none; border:1px solid var(--stroke-strong);
      background:#191a23; color:#cfd0dc; font-size:12px;
      border-radius:12px; padding:8px 10px; cursor:pointer;
    }
    .reset:hover{filter:brightness(1.05)}

    .mic-rail{display:flex; justify-content:center}
    .mic{
      appearance:none; border:none; cursor:pointer;
      padding:18px 26px; border-radius:18px;
      font-size:18px; line-height:1; letter-spacing:.4px;
      font-family:'Montserrat',sans-serif; font-weight:800; text-transform:uppercase;
      background:linear-gradient(180deg,#fff,#eee); color:#000;
      box-shadow:0 8px 20px rgba(0,0,0,.25);
      min-width:240px;
      transition:transform .15s ease, opacity .15s ease, background .15s ease;
    }
    .mic:hover{transform:translateY(-1px)}
    .mic:active{transform:translateY(0)}
    .mic.listening{background:linear-gradient(180deg,var(--warn),#ffdf8a)}
    .mic.stopping{background:linear-gradient(180deg,var(--stop),#ff8a8a); color:#000}
    .mic[disabled]{opacity:.45; cursor:not-allowed}

    .status-rail{display:flex; justify-content:center}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      background:#191a23; border:1px solid var(--stroke-strong);
      color:#cfd0dc; border-radius:999px; padding:7px 12px;
      font-size:12px; letter-spacing:.2px;
      box-shadow:0 6px 16px rgba(0,0,0,.25);
    }
    .dot{width:8px; height:8px; border-radius:999px; background:#666}
    .pill.listening .dot{background:#f7c948}
    .pill.thinking  .dot{background:#8a8cff}
    .pill.speaking  .dot{background:#16db65}
    .pill.ready     .dot{background:#6f7284}

    .instructions{
      text-align:center;
      font-family:'Montserrat',sans-serif; font-weight:800; text-transform:uppercase;
      color:#d8d9e3; letter-spacing:.4px; font-size:14px;
    }
    .instructions small{display:block; color:#bfc1cd; margin-top:6px; font-size:9px}

    .prompt-grid{
      display:flex; flex-wrap:wrap; justify-content:center;
      gap:12px 14px;
      margin:18px auto 36px;
      max-width:1000px;
      padding:0 6px;
    }
    .btn{
      appearance:none; border:none; cursor:pointer;
      padding:10px 14px;
      border-radius:16px; font-size:12px;
      font-family:'Montserrat',sans-serif; font-weight:700; text-transform:uppercase;
      background:linear-gradient(180deg,#fff,#efefef); color:#000;
      border:1px solid #e7e7e7;
      white-space:nowrap;
      transition:transform .15s ease, opacity .15s ease;
    }
    .btn:hover{transform:translateY(-1px)}
    .btn[disabled]{opacity:.45; cursor:not-allowed}
    .btn.active{background:linear-gradient(180deg,#e9ebff,#dfe1ff); border-color:#cfd1ff}

    .hero{display:flex; justify-content:center; position:relative}

    #dopHero{
      position: relative;
      width: 100%;
      max-width: 620px;
      margin: 16px auto 28px;
      aspect-ratio: 9 / 16;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 12px 32px rgba(0,0,0,.35);
      border: 1px solid var(--stroke-strong);
    }
    
    #dopHero > video,
    #dopHero > img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      cursor: pointer;
      outline: none;
      transition: opacity 320ms ease;
    }

    #resp{ display: none; }
    #dopImage{ display: block; }
    
    #resp:focus-visible{box-shadow:0 0 0 3px var(--accent)}
    .fade-start{opacity:0}

    .overlay { 
      position:absolute; 
      inset:0; 
      display:none; 
      align-items:center; 
      justify-content:center; 
      background:rgba(0,0,0,.18); 
      border-radius:14px; 
      pointer-events:none; 
    }
    .overlay.show{display:flex}
    
    .spinner{ 
      width:38px; 
      height:38px; 
      border-radius:999px; 
      border:3px solid rgba(255,255,255,.35); 
      border-top-color:#fff; 
      animation:spin 900ms linear infinite; 
      box-shadow:0 0 18px rgba(255,255,255,.25); 
    }
    
    @keyframes spin{to{transform:rotate(360deg)}}

    .footer{font-size:12px; color:#b7b8c3; text-align:center; margin-top:26px; margin-bottom:60px}

    .toast{ 
      position:fixed; 
      left:50%; 
      bottom:20px; 
      transform:translateX(-50%); 
      background:#1b1c25; 
      color:#eaeaf1; 
      border:1px solid var(--stroke-strong); 
      padding:10px 14px; 
      border-radius:12px; 
      box-shadow:var(--shadow); 
      font-size:12px; 
      letter-spacing:.2px; 
      opacity:0; 
      pointer-events:none; 
      transition:opacity .20s ease;
      z-index:1000;
    }
    .toast.show{opacity:1}

    .sr-only{ 
      position:absolute !important; 
      width:1px; 
      height:1px; 
      padding:0; 
      margin:-1px; 
      overflow:hidden; 
      clip:rect(0,0,0,0); 
      border:0; 
    }

    .dop-header{ 
      display:flex; 
      align-items:center; 
      gap:16px; 
      margin-bottom:24px; 
      padding:16px 0; 
      border-bottom:1px solid var(--stroke); 
    }
    .dop-avatar{ 
      width:50px; 
      height:50px; 
      border-radius:50%; 
      background:var(--stroke); 
      object-fit:cover; 
      border:2px solid var(--stroke-strong); 
    }
    .dop-info h1{ 
      margin:0; 
      font-size:1.5rem; 
      font-weight:700; 
      font-family:'Montserrat',sans-serif; 
    }
    .dop-info p{ 
      margin:4px 0 0; 
      color:#b7b8c3; 
      font-size:14px 
    }

    .loading-state{ 
      text-align:center; 
      padding:60px 20px; 
      color:#b7b8c3; 
    }
    .loading-state .spinner{margin:0 auto 20px}
    
    .error-state{ 
      text-align:center; 
      padding:40px; 
      color:#ff6b6b; 
    }
    .error-state .details{
      font-size:12px; 
      margin-top:8px; 
      color:#b7b8c3 
    }

    @media (max-width:480px){
      .dop-header{flex-direction:column; text-align:center}
      .mic{min-width:195px; font-size:16px; padding:16px 22px}
      .btn{width:100%}
      #dopHero{max-height:68vh}
      .prompt-grid{gap:10px 12px; margin:14px auto 26px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card section">
      <div class="loading-state" id="loadingState">
        <div class="spinner"></div>
        <div>Loading your DOP...</div>
      </div>

      <div class="error-state" id="errorState" style="display:none">
        <div>Sorry, this DOP couldn't be loaded.</div>
        <div class="details" id="errorDetails"></div>
      </div>

      <div id="mainInterface" style="display:none">
        <div class="dop-header" id="dopHeader" style="display:none">
          <img class="dop-avatar" id="dopAvatar" alt="DOP Avatar" />
          <div class="dop-info">
            <h1 id="dopName">Loading...</h1>
            <p id="dopBio">Loading personality...</p>
          </div>
        </div>

        <button class="reset" id="resetBtn" type="button" title="Reset session (clears local memory)">Reset Session</button>

        <div class="mic-rail">
          <button class="mic" id="micBtn" aria-pressed="false">🎤 Tap to Talk</button>
        </div>

        <div class="status-rail stack-s">
          <div id="statusPill" class="pill ready" aria-live="polite">
            <span class="dot"></span><span id="pillText">Ready</span>
          </div>
        </div>

        <div class="instructions stack-l">
          <span id="dopNameDisplay">Ask one of these questions.</span>
          <small>If your microphone doesn't work, tap the question.</small>
        </div>

        <div class="prompt-grid stack-m" id="promptGrid"></div>

        <div class="hero" id="dopHero">
          <video id="resp" playsinline preload="auto" tabindex="0" aria-label="Response video"></video>
          <img id="dopImage" alt="DOP Avatar" />
          <div class="overlay" id="respOverlay">
            <div class="spinner" aria-hidden="true"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="srStatus" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

  <script>
    // ========================================
    // CONSTANTS
    // ========================================
    const CONFIG = {
      MIC_LOCK_DURATION: 350,
      TTS_TIMEOUT: 12000,
      VIDEO_PRIME_TIME: 0.1,
      PRIME_DELAY: 80,
      PRELOAD_DELAY: 100,
      PRELOAD_SOURCES_DELAY: 300,
      TOAST_DURATION: 2000,
      TOAST_FADE_OUT: 250,
      MAX_CONTEXT_TURNS: 8,
      HEYGEN_POLL_INTERVAL: 3000,
      HEYGEN_POLL_MAX_ATTEMPTS: 80,
      PERSONA_POLL_INTERVAL: 4000,
      HAPTIC_DURATION: 60
    };

    // ========================================
    // GLOBALS & STATE
    // ========================================
    const urlParams = new URLSearchParams(window.location.search);
    const dopId = urlParams.get('id');

    let PERSONA_DATA = null;
    let PROMPTS_CONFIG = [];

    // ========================================
    // UTILITY FUNCTIONS
    // ========================================
    const qs = (selector, root = document) => root.querySelector(selector);
    const qsa = (selector, root = document) => Array.from(root.querySelectorAll(selector));

    function showToast(message) {
      const toast = document.createElement('div');
      toast.className = 'toast show';
      toast.textContent = message;
      document.body.append(toast);
      
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), CONFIG.TOAST_FADE_OUT);
      }, CONFIG.TOAST_DURATION);
    }

    function guessKey(text = '') {
      const t = text.toLowerCase();
      if (t.includes('fun')) return 'fun';
      if (t.includes('from')) return 'from';
      if (t.includes('relax')) return 'relax';
      return t.replace(/[^a-z]/g, '').slice(0, 12) || 'q1';
    }

    function haptic() {
      if ('vibrate' in navigator) {
        navigator.vibrate(CONFIG.HAPTIC_DURATION);
      }
    }

    async function safeJSON(response) {
      const text = await response.text();
      try {
        return JSON.parse(text);
      } catch (error) {
        throw new Error('Non-JSON response: ' + text.slice(0, 120));
      }
    }

    async function callFunction(url, payload) {
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      
      if (!response.ok) {
        throw new Error(`${url} returned ${response.status}`);
      }
      
      return await safeJSON(response);
    }

    // ========================================
    // MEDIA CONTROL
    // ========================================
    class MediaController {
      constructor() {
        this.videoEl = null;
        this.imageEl = null;
        this.overlayEl = null;
      }

      init() {
        this.videoEl = qs('#resp');
        this.imageEl = qs('#dopImage');
        this.overlayEl = qs('#respOverlay');
      }

      showVideo() {
        if (this.videoEl) this.videoEl.style.display = 'block';
        if (this.imageEl) this.imageEl.style.display = 'none';
      }

      showImage() {
        if (this.videoEl) this.videoEl.style.display = 'none';
        if (this.imageEl) this.imageEl.style.display = 'block';
      }

      showSpinner() {
        if (this.overlayEl) this.overlayEl.classList.add('show');
      }

      hideSpinner() {
        if (this.overlayEl) this.overlayEl.classList.remove('show');
      }

      async playVideo(url) {
        if (!this.videoEl) return;
        
        console.log('[MediaController] Playing video:', url);
        this.showVideo();
        this.showSpinner();
        
        this.videoEl.src = url;
        this.videoEl.load();

        return new Promise((resolve, reject) => {
          this.videoEl.onloadeddata = () => {
            this.hideSpinner();
            this.videoEl.play().catch(error => {
              console.warn('[MediaController] Autoplay blocked:', error);
              showToast('Tap video to play');
            });
            resolve();
          };

          this.videoEl.onerror = (error) => {
            console.error('[MediaController] Video load error:', error);
            this.hideSpinner();
            reject(error);
          };
        });
      }

      stopVideo() {
        if (this.videoEl && !this.videoEl.paused) {
          this.videoEl.pause();
        }
      }

      setVideoSource(src) {
        if (!this.videoEl) return;
        this.videoEl.src = src;
        this.videoEl.load();
      }

      setImageSource(src) {
        if (!this.imageEl) return;
        this.imageEl.src = src;
      }
    }

    const mediaController = new MediaController();

    // ========================================
    // PERSONA LOADER
    // ========================================
    async function loadPersona() {
      const loadingEl = qs('#loadingState');
      const errorEl = qs('#errorState');
      const errorDetails = qs('#errorDetails');
      const mainUI = qs('#mainInterface');
      const header = qs('#dopHeader');
      const nameEl = qs('#dopName');
      const bioEl = qs('#dopBio');
      const avatarEl = qs('#dopAvatar');

      try {
        if (!dopId) {
          // Default demo persona
          PERSONA_DATA = {
            name: 'Sasha',
            bio: 'Demo persona',
            prompts: [
              'What do you like to do for fun?',
              'Where are you from?',
              "What's your favorite way to relax?"
            ]
          };
          
          PROMPTS_CONFIG = [
            { question: 'What do you like to do for fun?', file: 'assets/p_fun.mp4', videoUrl: null },
            { question: 'Where are you from?', file: 'assets/p_from.mp4', videoUrl: null },
            { question: 'What's your favorite way to relax?', file: 'assets/p_relax.mp4', videoUrl: null }
          ];
          
          mediaController.showVideo();
        } else {
          // Load personalized DOP
          const response = await fetch(`/.netlify/functions/dop-persona?id=${encodeURIComponent(dopId)}`);
          
          if (!response.ok) {
            throw new Error(`dop-persona returned ${response.status}`);
          }
          
          const persona = await response.json();
          PERSONA_DATA = persona;

          // Set up image loading with spinner
          if (persona.images && persona.images.length > 0) {
            const firstImage = persona.images[0];
            const imageUrl = firstImage.url || firstImage.src || 
              (firstImage.key ? `/.netlify/functions/dop-file?key=${encodeURIComponent(firstImage.key)}` : '');
            
            if (imageUrl) {
              mediaController.setImageSource(imageUrl);
              mediaController.showImage();
              mediaController.showSpinner();
            }
          }

          // Set up video loaded handler
          mediaController.videoEl.addEventListener('loadeddata', () => {
            mediaController.showVideo();
            mediaController.hideSpinner();
          }, { once: true });

          // Update header
          header.style.display = 'flex';
          nameEl.textContent = persona.name || 'DOP';
          bioEl.textContent = persona.bio || 'Your AI doppelgänger';
          qs('#dopNameDisplay').textContent = `Ask ${persona.name || 'DOP'} one of these questions.`;

          // Set avatar image
          let avatarUrl = null;
          if (persona.image) {
            avatarUrl = persona.image.startsWith('data:') 
              ? persona.image 
              : `data:image/jpeg;base64,${persona.image}`;
          } else if (persona.images && persona.images[0]?.url) {
            avatarUrl = persona.images[0].url;
          }
          
          if (avatarUrl && avatarEl) {
            avatarEl.src = avatarUrl;
          }

          // Build prompts config
          const rawPrompts = Array.isArray(persona.prompts) ? persona.prompts : [];
          const videosByKey = Object.fromEntries(
            (persona.videos || []).map(v => [String(v.key || '').toLowerCase(), v.url])
          );

          PROMPTS_CONFIG = rawPrompts.map((prompt, index) => {
            const promptObj = typeof prompt === 'string' 
              ? { key: guessKey(prompt), text: prompt } 
              : prompt;
            
            const key = String(promptObj.key || '').toLowerCase();
            const videoUrl = videosByKey[key] ?? persona.videoUrls?.[`prompt${index}`] ?? null;
            
            return {
              question: promptObj.text || 'Ask me something',
              file: null,
              videoUrl
            };
          });
        }

        // Render prompt buttons
        const grid = qs('#promptGrid');
        grid.innerHTML = PROMPTS_CONFIG.map((prompt, index) =>
          `<button class="btn" data-index="${index}">${(prompt.question || '').toUpperCase()}</button>`
        ).join('');

        // Show main UI
        loadingEl.style.display = 'none';
        mainUI.style.display = 'block';

        // Initialize app
        initializeApp();

        // Continue polling if still processing
        if (dopId && PERSONA_DATA.status !== 'ready') {
          setTimeout(loadPersona, CONFIG.PERSONA_POLL_INTERVAL);
        }

      } catch (error) {
        console.error('[Persona] Load error:', error);
        loadingEl.style.display = 'none';
        errorEl.style.display = 'block';
        errorDetails.textContent = error.message || String(error);
      }
    }

    // ========================================
    // MAIN APP INITIALIZATION
    // ========================================
    function initializeApp() {
      mediaController.init();

      // Cache DOM elements
      const micBtn = qs('#micBtn');
      const resetBtn = qs('#resetBtn');
      const statusPill = qs('#statusPill');
      const pillText = qs('#pillText');
      const srStatus = qs('#srStatus');
      const grid = qs('#promptGrid');

      // Disable mic for user-generated DOPs
      const isUserDOP = !!dopId;
      if (isUserDOP) {
        micBtn.disabled = true;
        micBtn.title = 'Upgrade to have a conversation';
      }

      // ========================================
      // SESSION MANAGEMENT
      // ========================================
      let sessionId = `sess_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
      let conversationHistory = [];

      function pushTurn(role, content, metadata = {}) {
        conversationHistory.push({ role, content, ...metadata });
        
        const maxLength = CONFIG.MAX_CONTEXT_TURNS * 2;
        if (conversationHistory.length > maxLength) {
          conversationHistory.splice(0, conversationHistory.length - maxLength);
        }
      }

      function getBoundedContext() {
        return conversationHistory
          .slice(-CONFIG.MAX_CONTEXT_TURNS * 2)
          .map(turn => ({ role: turn.role, content: turn.content }));
      }

      function resetSession() {
        if (confirm('Reset conversation memory?')) {
          conversationHistory = [];
          sessionId = `sess_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
          stopAll();
          setIdleUI();
          showToast('Session reset');
        }
      }

      // Expose for external use
      window.DTA_reset = resetSession;

      // ========================================
      // STATE & AUDIO
      // ========================================
      let currentFile = null;
      let lastFile = null;
      let lastMode = null;
      let lastText = '';
      let isStopped = false;
      let micLocked = false;
      let currentAudio = null;
      let currentAudioURL = null;

      function lockMic() {
        micLocked = true;
        setTimeout(() => {
          micLocked = false;
        }, CONFIG.MIC_LOCK_DURATION);
      }

      // ========================================
      // UI STATE MANAGEMENT
      // ========================================
      function setPill(mode, text) {
        statusPill.classList.remove('listening', 'thinking', 'speaking', 'ready');
        statusPill.classList.add(mode);
        pillText.textContent = text;
        srStatus.textContent = text;
      }

      function setListeningUI() {
        micBtn.classList.add('listening');
        micBtn.textContent = '⏹ Stop';
        setPill('listening', 'Listening…');
      }

      function setThinkingUI() {
        micBtn.classList.remove('listening', 'stopping');
        micBtn.textContent = '🎤 Tap to Talk';
        setPill('thinking', 'Thinking…');
      }

      function setPlayingUI() {
        micBtn.classList.remove('listening', 'stopping');
        micBtn.textContent = '🎤 Tap to Talk';
        setPill('speaking', 'Speaking…');
      }

      function setIdleUI() {
        micBtn.classList.remove('listening', 'stopping');
        micBtn.textContent = '🎤 Tap to Talk';
        setPill('ready', 'Ready');
      }

      // ========================================
      // PLAYBACK CONTROL
      // ========================================
      function stopAll() {
        mediaController.stopVideo();
        stopASR();
        stopAudio();
        setIdleUI();
        mediaController.hideSpinner();
      }

      function stopAudio() {
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.src = '';
        }
        if (currentAudioURL) {
          URL.revokeObjectURL(currentAudioURL);
        }
        currentAudio = null;
        currentAudioURL = null;
      }

      // ========================================
      // VOICE MAPPING
      // ========================================
      window.DOP_LAST_PROMPT = null;

      function getVoiceIdForNextTTS() {
        return PERSONA_DATA?.voiceId || null;
      }

      function setVoiceForNextTTSByFile(file) {
        if (!file) return;
        const key = file.replace(/^assets\//, '').replace(/\.mp4$/i, '');
        window.DOP_LAST_PROMPT = key;
      }

      function forceFallbackVoiceForMic() {
        if (!window.DOP_LAST_PROMPT) {
          window.DOP_LAST_PROMPT = 'fallback';
        }
      }

      // ========================================
      // VIDEO PRELOADING
      // ========================================
      function preloadSources(firstFile) {
        if (!firstFile) return;
        
        setTimeout(() => {
          PROMPTS_CONFIG.forEach(prompt => {
            if (prompt.file) {
              const video = document.createElement('video');
              video.src = prompt.file;
              video.preload = 'auto';
              video.load();
            }
          });
        }, CONFIG.PRELOAD_DELAY);
      }

      function primeFirstFrame(file) {
        if (!file || !mediaController.videoEl) return;
        
        mediaController.videoEl.src = file;
        mediaController.videoEl.classList.add('fade-start');
        mediaController.videoEl.load();
        
        setTimeout(() => {
          mediaController.videoEl.currentTime = CONFIG.VIDEO_PRIME_TIME;
          mediaController.videoEl.classList.remove('fade-start');
        }, CONFIG.PRIME_DELAY);
      }

      // ========================================
      // VIDEO PLAYBACK
      // ========================================
      async function playFile(file) {
        if (!file) return;
        
        console.log('[App] Playing file:', file);
        currentFile = file;
        lastFile = file;
        lastMode = 'clip';
        lastText = '';
        isStopped = false;

        stopAll();
        setPlayingUI();
        mediaController.showSpinner();

        pushTurn('user', findQuestionForFile(file), { inputType: 'button' });

        try {
          await mediaController.playVideo(file);
          const transcript = findTranscriptForFile(file);
          if (transcript) {
            console.log('[App] Assistant transcript:', transcript);
          }
        } catch (error) {
          console.error('[App] Video playback error:', error);
          setIdleUI();
        }
      }

      async function playHeyGenVideo(videoUrl) {
        if (!videoUrl) return;
        
        console.log('[App] Playing HeyGen video:', videoUrl.substring(0, 80) + '…');
        currentFile = videoUrl;
        lastFile = videoUrl;
        lastMode = 'heygen';
        lastText = '';
        isStopped = false;

        stopAll();
        setPlayingUI();

        try {
          await mediaController.playVideo(videoUrl);
        } catch (error) {
          console.error('[App] HeyGen video playback error:', error);
          setIdleUI();
        }

        // Return to image when video ends
        mediaController.videoEl.addEventListener('ended', () => {
          mediaController.showImage();
          setIdleUI();
        }, { once: true });
      }

      // Expose for external use
      window.playHeyGenVideo = playHeyGenVideo;

      function findQuestionForFile(file) {
        const match = PROMPTS_CONFIG.find(p => p.file === file);
        return match ? match.question : '';
      }

      function findTranscriptForFile(file) {
        const match = PROMPTS_CONFIG.find(p => p.file === file);
        return match ? match.response || '' : '';
      }

      // ========================================
      // EVENT HANDLERS
      // ========================================
      mediaController.videoEl.addEventListener('click', () => {
        if (mediaController.videoEl.paused) {
          mediaController.videoEl.play().catch(error => {
            console.warn('[App] Play error:', error);
          });
          isStopped = false;
          setPlayingUI();
        } else {
          mediaController.stopVideo();
          setIdleUI();
          mediaController.hideSpinner();
        }
      });

      grid.addEventListener('click', (event) => {
        const btn = event.target.closest('.btn');
        if (!btn) return;
        
        const index = parseInt(btn.dataset.index, 10);
        const promptConfig = PROMPTS_CONFIG[index];

        if (promptConfig.videoUrl) {
          playHeyGenVideo(promptConfig.videoUrl);
        } else if (promptConfig.file) {
          setVoiceForNextTTSByFile(promptConfig.file);
          playFile(promptConfig.file);
        } else {
          const question = promptConfig.question;
          pushTurn('user', question, { inputType: 'button' });
          setPill('thinking', 'Thinking…');
          routeToBackend(question, { forceLLM: true });
        }
      });

      mediaController.videoEl.addEventListener('ended', () => {
        mediaController.stopVideo();
        setIdleUI();
      });

      mediaController.videoEl.addEventListener('error', () => {
        mediaController.stopVideo();
        setIdleUI();
        mediaController.hideSpinner();
      });

      // ========================================
      // SPEECH RECOGNITION (ASR)
      // ========================================
      const supportsASR = ('SpeechRecognition' in window) || ('webkitSpeechRecognition' in window);
      let recognizer = null;
      let recognizing = false;
      let finalTranscript = '';
      let asrFinalSent = false;

      if (!supportsASR) {
        micBtn.disabled = true;
        srStatus.textContent = 'Speech input not available.';
      }

      function initRecognizer() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognizer = new SpeechRecognition();
        recognizer.lang = 'en-US';
        recognizer.interimResults = true;
        recognizer.continuous = false;

        recognizer.onstart = () => {
          recognizing = true;
          finalTranscript = '';
          asrFinalSent = false;
          stopAll();
          setListeningUI();
          srStatus.textContent = 'Listening…';
          lockMic();
          haptic();
          forceFallbackVoiceForMic();
        };

        recognizer.onerror = (event) => {
          console.error('[ASR] Error:', event.error);
          srStatus.textContent = `Mic error: ${event.error || 'unknown'}`;
          stopASR();
          setIdleUI();
          mediaController.hideSpinner();
        };

        recognizer.onend = () => {
          recognizing = false;
          if (!asrFinalSent) {
            setIdleUI();
          }
        };

        recognizer.onresult = (event) => {
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const result = event.results[i];
            
            if (result.isFinal) {
              finalTranscript += result[0].transcript.trim() + ' ';
              
              if (!asrFinalSent) {
                asrFinalSent = true;
                const text = finalTranscript.trim();
                
                if (text) {
                  try {
                    stopASR();
                  } catch (error) {
                    console.error('[ASR] Stop error:', error);
                  }
                  
                  pushTurn('user', text, { inputType: 'mic' });
                  srStatus.textContent = 'Processing…';
                  setPill('thinking', 'Thinking…');
                  routeToBackend(text, { forceLLM: true });
                }
              }
            }
          }
        };
      }

      function startASR() {
        if (!recognizer) {
          initRecognizer();
        }
        
        try {
          recognizer.start();
        } catch (error) {
          console.warn('[ASR] Start error, retrying:', error);
          try {
            recognizer.stop();
            recognizer.start();
          } catch (retryError) {
            console.error('[ASR] Retry failed:', retryError);
          }
        }
      }

      function stopASR() {
        if (recognizer && recognizing) {
          recognizer.stop();
        }
        recognizing = false;
      }

      micBtn.addEventListener('click', () => {
        if (micLocked) return;
        
        if (micBtn.textContent.includes('Stop')) {
          stopAll();
          lockMic();
          return;
        }
        
        if (!supportsASR) return;
        
        startASR();
      });

      window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          stopAll();
        }
      });

      // ========================================
      // BACKEND COMMUNICATION
      // ========================================
      async function routeToBackend(text, options = {}) {
        const payload = {
          text,
          message: text,
          sessionId,
          context: getBoundedContext(),
          personaId: dopId,
          ...options
        };

        try {
          const data = await callFunction('/.netlify/functions/session-chat', payload);
          await handleBackendResponse(data);
        } catch (error) {
          console.warn('[Backend] session-chat failed, falling back to dop-chat:', error);
          
          try {
            const data = await callFunction('/.netlify/functions/dop-chat', { text });
            await handleBackendResponse(data);
            showToast('Using fallback chat');
          } catch (fallbackError) {
            console.error('[Backend] dop-chat also failed:', fallbackError);
            srStatus.textContent = 'Backend error';
            setIdleUI();
            showToast('Backend error. Please try again.');
          }
        }
      }

      // Expose for external use
      window.routeToBackend = routeToBackend;

      async function handleBackendResponse(data) {
        if (data.matchedClip) {
          setPlayingUI();
          await playFile(data.matchedClip);
        } else if (data.fallbackResponse || data.reply) {
          setPlayingUI();
          const speech = data.fallbackResponse || data.reply;
          lastMode = 'tts';
          lastText = speech;
          pushTurn('assistant', speech, { audio: true });
          await speakWithElevenLabs(speech);
          setIdleUI();
        } else {
          setIdleUI();
        }
      }

      // ========================================
      // TEXT-TO-SPEECH
      // ========================================
      async function speakWithElevenLabs(text) {
        try {
          mediaController.stopVideo();
          mediaController.showSpinner();

          let clipHint = null;
          if (lastFile && typeof lastFile === 'string') {
            clipHint = lastFile.replace(/^assets\//, '').replace(/\.mp4$/i, '');
          }
          if (!clipHint && window.DOP_LAST_PROMPT) {
            clipHint = window.DOP_LAST_PROMPT;
          }

          const response = await fetch('/.netlify/functions/tts-eleven', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              text,
              clip: clipHint,
              voiceId: getVoiceIdForNextTTS()
            })
          });

          if (!response.ok) {
            throw new Error('TTS request failed');
          }

          const buffer = await response.arrayBuffer();
          const blob = new Blob([buffer], { type: 'audio/mpeg' });
          const url = URL.createObjectURL(blob);
          currentAudioURL = url;
          currentAudio = new Audio(url);

          setPill('speaking', 'Speaking…');
          
          await currentAudio.play().catch(error => {
            console.warn('[TTS] Play error:', error);
          });

          await new Promise((resolve) => {
            const cleanup = () => {
              if (currentAudio) {
                currentAudio.removeEventListener('ended', cleanup);
              }
              resolve();
            };
            currentAudio.addEventListener('ended', cleanup, { once: true });
          });

        } catch (error) {
          console.warn('[TTS] ElevenLabs error, falling back to device TTS:', error);
          
          // Fallback to browser TTS
          if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';
            setPill('speaking', 'Speaking…');
            
            try {
              speechSynthesis.cancel();
              speechSynthesis.speak(utterance);
            } catch (synthError) {
              console.error('[TTS] Browser TTS error:', synthError);
            }

            await new Promise((resolve) => {
              utterance.onend = resolve;
              setTimeout(resolve, CONFIG.TTS_TIMEOUT);
            });
          }
        } finally {
          mediaController.hideSpinner();
          
          try {
            if (currentAudio) {
              currentAudio.pause();
              currentAudio.src = '';
            }
            if (currentAudioURL) {
              URL.revokeObjectURL(currentAudioURL);
            }
          } catch (cleanupError) {
            console.error('[TTS] Cleanup error:', cleanupError);
          }
          
          currentAudio = null;
          currentAudioURL = null;
        }
      }

      // ========================================
      // RESET BUTTON
      // ========================================
      resetBtn.addEventListener('click', resetSession);

      // ========================================
      // INITIALIZATION
      // ========================================
      const firstPrompt = PROMPTS_CONFIG[0];
      if (firstPrompt && firstPrompt.file) {
        primeFirstFrame(firstPrompt.file);
        setTimeout(() => {
          preloadSources(firstPrompt.file);
        }, CONFIG.PRELOAD_SOURCES_DELAY);
      }

      // Pre-warm TTS function
      window.addEventListener('load', () => {
        fetch('/.netlify/functions/tts-eleven', { method: 'OPTIONS' })
          .catch(() => {
            // Silently ignore - just warming up
          });
      });
    }

    // ========================================
    // START APPLICATION
    // ========================================
    loadPersona();
  </script>
</body>
</html>