<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Chat with DOP - Dopple Talent Agency</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0e0f12; --bg-2:#08090c;
      --panel:#12131a; --panel-2:#1a1b25;
      --text:#ececf1; --muted:#b7b8c3;
      --stroke:#26283a; --stroke-strong:#3a3b52;
      --accent:#8a8cff;
      --ok:#16db65; --warn:#ffd166; --stop:#ff6b6b;
      --shadow:0 10px 30px rgba(0,0,0,.35); --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 80% -10%, rgba(94,97,255,.12), transparent 40%),
        radial-gradient(900px 480px at 0% 110%, rgba(138,140,255,.10), transparent 45%),
        linear-gradient(180deg,var(--bg),var(--bg-2));
      min-height:100vh;
    }

    .wrap{max-width:1100px; margin:0 auto; padding:28px 20px 48px}
    .card{
      position:relative;
      background:linear-gradient(180deg,var(--panel),var(--panel-2));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:26px 22px 32px;
      margin:18px 0;
    }
    .section{max-width:980px; margin:0 auto}
    .stack-s{margin-top:8px}
    .stack-m{margin-top:16px}
    .stack-l{margin-top:24px}
    .stack-xl{margin-top:32px}

    .reset{
      position:absolute; right:18px; top:18px;
      appearance:none; border:1px solid var(--stroke-strong);
      background:#191a23; color:#cfd0dc; font-size:12px;
      border-radius:12px; padding:8px 10px; cursor:pointer;
    }
    .reset:hover{filter:brightness(1.05)}

    .mic-rail{display:flex; justify-content:center}
    .mic{
      appearance:none; border:none; cursor:pointer;
      padding:18px 26px; border-radius:18px;
      font-size:18px; line-height:1; letter-spacing:.4px;
      font-family:'Montserrat',sans-serif; font-weight:800; text-transform:uppercase;
      background:linear-gradient(180deg,#fff,#eee); color:#000;
      box-shadow:0 8px 20px rgba(0,0,0,.25);
      min-width:240px;
      transition:transform .15s ease, opacity .15s ease, background .15s ease;
    }
    .mic:hover{transform:translateY(-1px)}
    .mic:active{transform:translateY(0)}
    .mic.listening{background:linear-gradient(180deg,var(--warn),#ffdf8a)}
    .mic.stopping{background:linear-gradient(180deg,var(--stop),#ff8a8a); color:#000}
    .mic[disabled]{opacity:.45; cursor:not-allowed}

    .status-rail{display:flex; justify-content:center}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      background:#191a23; border:1px solid var(--stroke-strong);
      color:#cfd0dc; border-radius:999px; padding:7px 12px;
      font-size:12px; letter-spacing:.2px;
      box-shadow:0 6px 16px rgba(0,0,0,.25);
    }
    .dot{width:8px; height:8px; border-radius:999px; background:#666}
    .pill.listening .dot{background:#f7c948}
    .pill.thinking  .dot{background:#8a8cff}
    .pill.speaking  .dot{background:#16db65}
    .pill.ready     .dot{background:#6f7284}

    .instructions{
      text-align:center;
      font-family:'Montserrat',sans-serif; font-weight:800; text-transform:uppercase;
      color:#d8d9e3; letter-spacing:.4px; font-size:14px;
    }
    .instructions small{display:block; color:#bfc1cd; margin-top:6px; font-size:9px}

    .prompt-grid{
      display:flex; flex-wrap:wrap; justify-content:center;
      gap:12px 14px;
      margin:18px auto 36px;
      max-width:1000px;
 /* --- DOP media area (container + media + overlay) --- */

.hero{
  position: relative;
  max-width: 560px;
  margin: 0 auto;
  border-radius: 16px;
  overflow: hidden;
  background: #000;
}
#resp, #dopImage{
  display: block;
  width: 100%;
  height: auto;
  background: #000;
}

/* Media elements fill the hero and are stacked */
.hero > video,
.hero > img,
.hero > .overlay{
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Video + image defaults */
#resp{ outline: none; cursor: pointer; opacity: 1; transition: opacity 320ms ease; }
#resp:focus-visible{ box-shadow: 0 0 0 3px var(--accent); }
.dop-image{ display: none; } /* JS will set to 'block' while we wait */

/* Loading overlay shown while we wait for the generated video */
.overlay{
  display: none;               /* JS toggles to 'flex' */
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,.18);
  border-radius: 14px;
  pointer-events: none;        /* clicks pass through to video */
}
.overlay.show{ display: flex; }

.overlay .spinner{
  width: 38px;
  height: 38px;
  border-radius: 999px;
  border: 3px solid rgba(255,255,255,.35);
  border-top-color: #fff;
  animation: spin 900ms linear infinite;
  box-shadow: 0 0 18px rgba(255,255,255,.25);
}

/* keep your existing keyframes (already in file) */
@keyframes spin{ to { transform: rotate(360deg); } }

  object-fit:cover;
}

/* start hidden; JS will flip these */
.hero > video{ display:none; }
.hero > img{ display:none; }

/* overlay uses flex to center the spinner */
#respOverlay{
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.18);
  border-radius:12px;
}

  </style>
</head>
<body>
  <div class="wrap">
    <div class="card section">
      <div class="loading-state" id="loadingState">
        <div class="spinner"></div>
        <div>Loading your DOP...</div>
      </div>

      <div class="error-state" id="errorState" style="display:none">
        <div>Sorry, this DOP couldn't be loaded.</div>
        <div class="details" id="errorDetails"></div>
      </div>

      <div id="mainInterface" style="display:none">
        <div class="dop-header" id="dopHeader" style="display:none">
          <img class="dop-avatar" id="dopAvatar" alt="DOP Avatar" />
          <div class="dop-info">
            <h1 id="dopName">Loading...</h1>
            <p id="dopBio">Loading personality...</p>
          </div>
        </div>

        <button class="reset" id="resetBtn" type="button" title="Reset session (clears local memory)">Reset Session</button>

        <div class="mic-rail">
          <button class="mic" id="micBtn" aria-pressed="false">ðŸŽ¤ Tap to Talk</button>
        </div>

        <div class="status-rail stack-s">
          <div id="statusPill" class="pill ready" aria-live="polite">
            <span class="dot"></span><span id="pillText">Ready</span>
          </div>
        </div>

        <div class="instructions stack-l">
          <span id="dopNameDisplay">Ask one of these questions.</span>
          <small>If your microphone doesn't work, tap the question.</small>
        </div>

        <div class="prompt-grid stack-m" id="promptGrid"></div>

   <div class="hero" style="position: relative;">
  <!-- Static uploaded photo (shown until video loads) -->
  <img id="dopImage"
       alt="DOP"
       style="display:none;width:100%;height:auto;border-radius:12px;object-fit:cover;position:absolute;top:0;left:0;" />

  <!-- Final DOP video -->
  <video id="resp"
         playsinline
         preload="auto"
         tabindex="0"
         aria-label="Response video (tap to play or pause)"
         style="display:none;width:100%;border-radius:12px;object-fit:cover;"></video>

  <!-- Spinner overlay -->
  <div id="respOverlay"
       style="display:none;position:absolute;inset:0;align-items:center;justify-content:center;background:rgba(0,0,0,.18);border-radius:12px;">
    <div class="spinner"></div>
  </div>
</div>



  <div id="srStatus" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

  <script>
    // -----------------------------
    // Helpers
    // -----------------------------
    const qs  = (s, r=document) => r.querySelector(s);
    const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));
    const urlParams = new URLSearchParams(window.location.search);
    const dopId = urlParams.get('id');

    let PERSONA_DATA = null;
    let PROMPTS_CONFIG = [];

    function showOverlay(){ qs('#respOverlay').classList.add('show'); }
    function hideOverlay(){ qs('#respOverlay').classList.remove('show'); }
    function setPill(mode, text){
      const pill = qs('#statusPill'), txt = qs('#pillText');
      pill.classList.remove('listening','thinking','speaking','ready');
      pill.classList.add(mode);
      txt.textContent = text;
      qs('#srStatus').textContent = text;
    }
    function showToast(msg){
      const t = document.createElement('div'); t.className='toast show'; t.textContent=msg;
      document.body.append(t); setTimeout(()=>{ t.classList.remove('show'); setTimeout(()=>t.remove(),250); }, 2000);
    }
    const guessKey = (t='')=>{
      t = t.toLowerCase();
      if (t.includes('fun')) return 'fun';
      if (t.includes('from')) return 'from';
      if (t.includes('relax')) return 'relax';
      return t.replace(/[^a-z]/g,'').slice(0,12) || 'q1';
    };

    // -----------------------------
    // Persona loader (uses dop-view)
    // -----------------------------
    async function loadPersona(){
      const loading  = qs('#loadingState');
      const errorBox = qs('#errorState');
      const details  = qs('#errorDetails');
      const mainUI   = qs('#mainInterface');

      const resp     = qs('#resp');
      const dopImg   = qs('#dopImage');
      const header   = qs('#dopHeader');
      const nameEl   = qs('#dopName');
      const bioEl    = qs('#dopBio');
      
      // Guard: if any required element is missing, bail gracefully
const overlay = qs('#respOverlay');
if (!resp || !dopImg || !overlay) {
  console.error('UI element missing', { resp, dopImg, overlay });
  showError('Sorry, this DOP couldnâ€™t be loaded. (ui-missing)');
  return;
}


      try{
        if (!dopId){
          // Default demo
          PERSONA_DATA = {
            name: 'Sasha',
            bio: 'Demo persona',
            prompts: [
              'What do you like to do for fun?',
              'Where are you from?',
              "Whatâ€™s your favorite way to relax?"
            ]
          };
          PROMPTS_CONFIG = [
            { question:'What do you like to do for fun?', file:'assets/p_fun.mp4',   videoUrl:null },
            { question:'Where are you from?',            file:'assets/p_from.mp4',  videoUrl:null },
            { question:'Whatâ€™s your favorite way to relax?', file:'assets/p_relax.mp4', videoUrl:null }
          ];
          resp.style.display = 'block';
          dopImg.style.display = 'none';
        } else {
          // Personalized DOP
          // Personalized DOP (use dop-persona)
const r = await fetch(`/.netlify/functions/dop-persona?id=${encodeURIComponent(dopId)}`);
if (!r.ok) throw new Error(`dop-persona ${r.status}`);
const persona = await r.json(); // same shape you saw in the JSON viewer

          PERSONA_DATA = persona;
          const overlay = qs('#respOverlay');
const imgEl   = qs('#dopImage');
const vidEl   = qs('#resp');

if (persona?.images?.length) {
  const first = persona.images[0];
  // Use existing absolute URLs, or resolve blob keys via your dop-file endpoint:
  imgEl.src = first.url || first.src || (first.key ? `/.netlify/functions/dop-file?key=${encodeURIComponent(first.key)}` : '');
  imgEl.style.display = 'block';
  overlay.style.display = 'flex';
}

// When the video actually has data, swap to it:
vidEl.addEventListener('loadeddata', () => {
  imgEl.style.display = 'none';
  overlay.style.display = 'none';
  vidEl.style.display = 'block';
});


          header.style.display = 'flex';
          nameEl.textContent = persona.name || 'DOP';
          bioEl.textContent  = persona.bio  || 'Your AI doppelgÃ¤nger';
          qs('#dopNameDisplay').textContent = `Ask ${PERSONA_DATA.name || 'DOP'} one of these questions.`;

          // portrait: legacy base64 or new blobs url
          let imageUrl = null;
          if (persona.image) {
            imageUrl = persona.image.startsWith('data:')
              ? persona.image
              : `data:image/jpeg;base64,${persona.image}`;
          } else if (Array.isArray(persona.images) && persona.images[0]?.url) {
            imageUrl = persona.images[0].url;
          }
          if (imageUrl){
            qs('#dopAvatar').src = imageUrl;
            dopImg.src = imageUrl;
            resp.style.display = 'none';
            dopImg.style.display = 'block';
          }

          // prompts + videos
          const raw = Array.isArray(persona.prompts) ? persona.prompts : [];
          const videosByKey = Object.fromEntries(
            (persona.videos || []).map(v => [String(v.key || '').toLowerCase(), v.url])
          );

          PROMPTS_CONFIG = raw.map((p, i)=>{
            const obj = (typeof p === 'string') ? { key: guessKey(p), text: p } : p;
            const k   = String(obj.key || '').toLowerCase();
            const vUrl = videosByKey[k] ?? persona.videoUrls?.[`prompt${i}`] ?? null;
            return { question: obj.text || 'Ask me something', file:null, videoUrl: vUrl };
          });
        }

        // Render buttons
        const grid = qs('#promptGrid');
        grid.innerHTML = PROMPTS_CONFIG.map((p, i) =>
          `<button class="btn" data-index="${i}">${(p.question||'').toUpperCase()}</button>`
        ).join('');

        // Show UI
        loading.style.display = 'none';
        mainUI.style.display  = 'block';

        initializeApp();

        // Poll while processing
        if (dopId && PERSONA_DATA.status !== 'ready') {
          setTimeout(loadPersona, 4000);
        }

      } catch (e){
        console.error('[chat] load error', e);
        loading.style.display = 'none';
        errorBox.style.display = 'block';
        details.textContent = e.message || String(e);
      }
    }

    // -----------------------------
    // App logic (kept from your original)
    // -----------------------------
    function initializeApp() {
      const resp = document.getElementById('resp');
      const respOverlay = document.getElementById('respOverlay');
      const micBtn = document.getElementById('micBtn');
      const resetBtn = document.getElementById('resetBtn');
      const statusPill = document.getElementById('statusPill');
      const pillText = document.getElementById('pillText');
      const srStatus = document.getElementById('srStatus');
      const grid = document.getElementById('promptGrid');
      const dopImage = document.getElementById('dopImage');

      // Disable mic for user-generated DOPs (upgrade required)
      const isUserDOP = !!dopId;
      if (isUserDOP) {
        micBtn.disabled = true;
        micBtn.title = 'Upgrade to have a conversation';
      }

      // Session
      let sessionId = 'sess_' + Date.now() + '_' + Math.random().toString(36).slice(2,9);
      let conversationHistory = [];
      const MAX_CONTEXT = 8;
      function pushTurn(role, content, meta={}){
        conversationHistory.push({ role, content, ...meta });
        if (conversationHistory.length > MAX_CONTEXT*2) {
          conversationHistory.splice(0, conversationHistory.length - MAX_CONTEXT*2);
        }
      }
      function getBoundedContext(){
        return conversationHistory.slice(-MAX_CONTEXT*2).map(t => ({ role:t.role, content:t.content }));
      }
      function resetSession(){
        if (confirm('Reset conversation memory?')) {
          conversationHistory = [];
          sessionId = 'sess_' + Date.now() + '_' + Math.random().toString(36).slice(2,9);
          stopAll();
          setIdleUI();
          showToast('Session reset');
        }
      }
      window.DTA_reset = resetSession;

      // State
      let currentFile = null, lastFile = null, lastMode = null, lastText = '';
      let isStopped = false, micLocked = false;
      let currentAudio = null, currentAudioURL = null;

      function haptic(){ if ('vibrate' in navigator) navigator.vibrate(60); }
      function lockMic(){ micLocked = true; setTimeout(() => micLocked = false, 350); }
      function showOverlay(){ respOverlay.classList.add('show'); }
      function hideOverlay(){ respOverlay.classList.remove('show'); }
      function showToast(msg){ const t = document.createElement('div'); t.className='toast show'; t.textContent=msg; document.body.append(t); setTimeout(() => { t.classList.remove('show'); setTimeout(() => t.remove(), 250); }, 2000); }

      function setPill(mode, text){
        statusPill.classList.remove('listening','thinking','speaking','ready');
        statusPill.classList.add(mode);
        pillText.textContent = text;
        srStatus.textContent = text;
      }
      function setListeningUI(){ micBtn.classList.add('listening'); micBtn.textContent = 'â¹ Stop'; setPill('listening','Listeningâ€¦'); }
      function setThinkingUI(){ micBtn.classList.remove('listening','stopping'); micBtn.textContent = 'ðŸŽ¤ Tap to Talk'; setPill('thinking','Thinkingâ€¦'); }
      function setPlayingUI(){ micBtn.classList.remove('listening','stopping'); micBtn.textContent = 'ðŸŽ¤ Tap to Talk'; setPill('speaking','Speakingâ€¦'); }
      function setIdleUI(){ micBtn.classList.remove('listening','stopping'); micBtn.textContent = 'ðŸŽ¤ Tap to Talk'; setPill('ready','Ready'); }

      function stopAll(){
        stopVideo();
        stopASR();
        stopAudio();
        setIdleUI();
        hideOverlay();
      }
      function stopVideo(){ if (resp && !resp.paused) resp.pause(); isStopped = true; }
      function stopAudio(){ if (currentAudio) { currentAudio.pause(); currentAudio.src=''; } if (currentAudioURL) URL.revokeObjectURL(currentAudioURL); currentAudio=null; currentAudioURL=null; }

      function safePlay(){ try { resp.play().catch(e => { console.warn('Autoplay blocked:',e); showToast('Tap video to play'); }); } catch{} }

      // Voice mapping logic (kept)
      window.DOP_LAST_PROMPT = null;
      function getVoiceIdForNextTTS(){
        if (!PERSONA_DATA.voiceId) return null;
        return PERSONA_DATA.voiceId;
      }
      function setVoiceForNextTTSByFile(file){ 
        if (!file) return;
        const key = file.replace(/^assets\//,'').replace(/\.mp4$/i,'');
        window.DOP_LAST_PROMPT = key;
      }
      function forceFallbackVoiceForMic(){ if (!window.DOP_LAST_PROMPT) window.DOP_LAST_PROMPT = 'fallback'; }

      // Player helpers
      function preloadSources(firstFile){
        if (!firstFile) return;
        setTimeout(() => {
          PROMPTS_CONFIG.forEach(p => {
            if (p.file) {
              const v = document.createElement('video');
              v.src = p.file; v.preload = 'auto'; v.load();
            }
          });
        }, 100);
      }
      function primeFirstFrame(file){
        if (!file || !resp) return;
        resp.src = file;
        resp.classList.add('fade-start');
        resp.load();
        setTimeout(() => { resp.currentTime = 0.1; resp.classList.remove('fade-start'); }, 80);
      }

      // Updated playFile (local demo fallback)
      function playFile(file) {
        if (!file) return;
        console.log('Playing file:', file);
        currentFile = file;
        lastFile = file;
        lastMode = 'clip';
        lastText = '';
        isStopped = false;

        stopAll();
        setPlayingUI();
        showOverlay();

        pushTurn('user', findQuestionForFile(file), { inputType: 'button' });

        resp.src = file;
        resp.load();

        resp.onloadeddata = () => {
          hideOverlay();
          safePlay();
          const transcript = findTranscriptForFile(file);
          if (transcript)
            console.log('[assistant transcript]', transcript);
        };

        resp.onerror = () => {
          hideOverlay();
          setIdleUI();
        };
      }

      function playHeyGenVideo(videoUrl){
        if (!videoUrl) return;
        console.log('Playing HeyGen video:', videoUrl.substring(0, 80) + 'â€¦');
        currentFile = videoUrl;
        lastFile = videoUrl;
        lastMode = 'heygen';
        lastText = '';
        isStopped = false;

        stopAll();
        setPlayingUI();
        showOverlay();

        // show the video, hide portrait
        dopImage.style.display = 'none';
        resp.style.display = 'block';

        resp.src = videoUrl;
        resp.load();
        resp.onloadeddata = () => {
          hideOverlay();
          safePlay();
        };
        resp.onerror = () => { 
          console.error('[chat] HeyGen video failed to load');
          hideOverlay(); 
          setIdleUI(); 
        };
        resp.onended = () => {
          resp.style.display = 'none';
          dopImage.style.display = 'block';
          setIdleUI();
        };
      }

      function findQuestionForFile(file){
        const match = PROMPTS_CONFIG.find(p => p.file === file);
        return match ? match.question : '';
      }
      function findTranscriptForFile(file){
        const match = PROMPTS_CONFIG.find(p => p.file === file);
        return match ? match.response || '' : '';
      }

      // Click handlers
      resp.addEventListener('click', () => {
        if (resp.paused) { safePlay(); isStopped = false; setPlayingUI(); }
        else { stopVideo(); setIdleUI(); hideOverlay(); }
      });

      grid.addEventListener('click', (e) => {
        const btn = e.target.closest('.btn');
        if (!btn) return;
        const index = parseInt(btn.dataset.index);
        const promptConfig = PROMPTS_CONFIG[index];

        if (promptConfig.videoUrl) {
          playHeyGenVideo(promptConfig.videoUrl);
        } else if (promptConfig.file) {
          setVoiceForNextTTSByFile(promptConfig.file);
          playFile(promptConfig.file);
        } else {
          const question = promptConfig.question;
          pushTurn('user', question, { inputType:'button' });
          setPill('thinking','Thinkingâ€¦');
          routeToBackend(question, { forceLLM: true });
        }
      });

      resp.addEventListener('ended', () => { stopVideo(); setIdleUI(); });
      resp.addEventListener('error', () => { stopVideo(); setIdleUI(); hideOverlay(); });

      // ASR + backend routing + ElevenLabs TTS (kept)
      const supportsASR = ('SpeechRecognition' in window) || ('webkitSpeechRecognition' in window);
      let recognizer = null, recognizing = false, finalTranscript = '';
      let asrFinalSent = false;

      if (!supportsASR) { micBtn.disabled = true; srStatus.textContent = 'Speech input not available.'; }

      function initRecognizer(){
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognizer = new SR();
        recognizer.lang = 'en-US';
        recognizer.interimResults = true;
        recognizer.continuous = false;

        recognizer.onstart = () => {
          recognizing = true; finalTranscript = ''; asrFinalSent = false;
          stopAll();
          setListeningUI();
          srStatus.textContent = 'Listeningâ€¦';
          lockMic();
          haptic();
          forceFallbackVoiceForMic();
        };
        recognizer.onerror = (e) => { srStatus.textContent = 'Mic error: ' + (e.error || 'unknown'); stopASR(); setIdleUI(); hideOverlay(); };
        recognizer.onend = () => { recognizing = false; if (!asrFinalSent) setIdleUI(); };
        recognizer.onresult = (event) => {
          for (let i = event.resultIndex; i < event.results.length; i++) {
            const res = event.results[i];
            if (res.isFinal) {
              finalTranscript += res[0].transcript.trim() + ' ';
              if (!asrFinalSent) {
                asrFinalSent = true;
                const text = finalTranscript.trim();
                if (text) {
                  try { stopASR(); } catch {}
                  pushTurn('user', text, { inputType:'mic' });
                  srStatus.textContent = 'Processingâ€¦';
                  setPill('thinking','Thinkingâ€¦');
                  routeToBackend(text, { forceLLM: true });
                }
              }
            }
          }
        };
      }
      function startASR(){ if (!recognizer) initRecognizer(); try { recognizer.start(); } catch { try { recognizer.stop(); recognizer.start(); } catch(_){} } }
      function stopASR(){ if (recognizer && recognizing) recognizer.stop(); recognizing = false; }

      micBtn.addEventListener('click', () => {
        if (micLocked) return;
        if (micBtn.textContent.includes('Stop')) { stopAll(); lockMic(); return; }
        if (!supportsASR) return;
        startASR();
      });
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') stopAll(); });

      async function safeJSON(res){
        const txt = await res.text();
        try { return JSON.parse(txt); }
        catch { throw new Error('Non-JSON response: ' + txt.slice(0,120)); }
      }
      async function callFunction(url, payload){
        const res = await fetch(url, {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error(`${url} ${res.status}`);
        return await safeJSON(res);
      }

      async function routeToBackend(text, opts = {}){
        const payload = { text, message:text, sessionId, context:getBoundedContext(), personaId:dopId, ...opts };
        try{
          const data = await callFunction('/.netlify/functions/session-chat', payload);
          await handleBackendResponse(data);
        } catch (e1){
          console.warn('[DTA] session-chat failed, falling back â†’ dop-chat', e1);
          try{
            const data = await callFunction('/.netlify/functions/dop-chat', { text });
            await handleBackendResponse(data);
            showToast('Using fallback chat');
          } catch (e2){
            console.error('[DTA] dop-chat also failed', e2);
            srStatus.textContent = 'Backend error';
            setIdleUI();
            showToast('Backend error');
          }
        }
      }

      async function handleBackendResponse(data){
        if (data.matchedClip) {
          setPlayingUI();
          playFile(data.matchedClip);
        } else if (data.fallbackResponse || data.reply) {
          setPlayingUI();
          const speech = data.fallbackResponse || data.reply;
          lastMode = 'tts';
          lastText = speech;
          pushTurn('assistant', speech, { audio:true });
          await speakWithElevenLabs(speech);
          setIdleUI();
        } else {
          setIdleUI();
        }
      }

      async function speakWithElevenLabs(text){
        try{
          stopVideo();
          showOverlay();
          let clipHint = null;
          if (lastFile && typeof lastFile === 'string') {
            clipHint = lastFile.replace(/^assets\//,'').replace(/\.mp4$/i,'');
          }
          if (!clipHint && window.DOP_LAST_PROMPT) clipHint = window.DOP_LAST_PROMPT;

          const res = await fetch('/.netlify/functions/tts-eleven', {
            method:'POST',
            headers:{ 'Content-Type':'application/json' },
            body: JSON.stringify({ text, clip: clipHint, voiceId: getVoiceIdForNextTTS() })
          });
          if (!res.ok) throw new Error('TTS failed');

          const buf = await res.arrayBuffer();
          const blob = new Blob([buf], { type: 'audio/mpeg' });
          const url = URL.createObjectURL(blob);
          currentAudioURL = url;
          currentAudio = new Audio(url);

          setPill('speaking','Speakingâ€¦');
          await currentAudio.play().catch(()=>{});
          await new Promise((resolve) => {
            const cleanup = () => { currentAudio && currentAudio.removeEventListener('ended', cleanup); resolve(); };
            currentAudio.addEventListener('ended', cleanup, { once:true });
          });
        } catch(e){
          console.warn('ElevenLabs TTS error, falling back to device TTS', e);
          if ('speechSynthesis' in window) {
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'en-US';
            setPill('speaking','Speakingâ€¦');
            try { speechSynthesis.cancel(); speechSynthesis.speak(u); } catch {}
            await new Promise((resolve) => { u.onend = resolve; setTimeout(resolve, 12000); });
          }
        } finally {
          hideOverlay();
          try{
            if (currentAudio) { currentAudio.pause(); currentAudio.src=''; }
            if (currentAudioURL) URL.revokeObjectURL(currentAudioURL);
          }catch{}
          currentAudio=null; currentAudioURL=null;
        }
      }

      // Reset button
      resetBtn.addEventListener('click', resetSession);

      // Boot
      const firstPrompt = PROMPTS_CONFIG[0];
      if (firstPrompt && firstPrompt.file) {
        primeFirstFrame(firstPrompt.file);
        setTimeout(() => preloadSources(firstPrompt.file), 300);
      }

      // Pre-warm TTS function
      window.addEventListener('load', () => {
        fetch('/.netlify/functions/tts-eleven', { method:'OPTIONS' }).catch(()=>{});
      });
    }

    // Kick off
    loadPersona();
  </script>
</body>
</html>
