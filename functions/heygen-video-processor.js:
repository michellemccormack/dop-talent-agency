// functions/heygen-video-processor.js
// Background / Scheduled function to finish HeyGen renders and update persona JSON.
// Add-only file. Uses your existing heygen-proxy.js endpoints and Blobs helper.
//
// How it works:
// 1) Lists all personas in the uploads store (prefix: "personas/")
// 2) For any persona with status !== "ready", ensure each prompt has a render job
// 3) Polls job status until a video_url is returned
// 4) Writes back persona JSON with videos[] and status: "ready" when all are present
//
// You can invoke this two ways:
//  - Manually (GET): /.netlify/functions/heygen-video-processor
//  - On a schedule (add to netlify.toml):
//      [[scheduled]]
//      path = "/.netlify/functions/heygen-video-processor"
//      schedule = "*/2 * * * *"   # every 2 minutes
//
const fetch = global.fetch;
const { uploadsStore } = require('./_lib/blobs');

const CORS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
  'Access-Control-Allow-Headers': 'content-type, authorization'
};

const DEFAULT_PROMPTS = [
  { key: 'fun',   text: 'What do you like to do for fun?' },
  { key: 'from',  text: 'Where are you from?' },
  { key: 'relax', text: 'What’s your favorite way to relax?' }
];

// Helper: sleep in async loops
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

function ok(body) { return { statusCode: 200, headers: { ...CORS, 'content-type': 'application/json' }, body: JSON.stringify(body) }; }
function err(code, message, extra={}) { return { statusCode: code, headers: { ...CORS, 'content-type': 'application/json' }, body: JSON.stringify({ error: message, ...extra }) }; }

// Minimal, defensive read/write
async function readPersona(store, key) {
  try {
    const raw = await store.get(key, { type: 'text' });
    if (!raw) return null;
    return JSON.parse(raw);
  } catch (e) {
    console.warn('[processor] failed to parse persona', key, e?.message);
    return null;
  }
}
async function writePersona(store, key, persona) {
  try {
    await store.set(key, JSON.stringify(persona));
    return true;
  } catch (e) {
    console.error('[processor] failed to write persona', key, e?.message);
    return false;
  }
}

// Call your local proxy so we keep tokens in one place
async function heygenGenerate({ avatar_id, voice_id, script, ratio = '9:16', quality = 'high' }) {
  const res = await fetch('/.netlify/functions/heygen-proxy?action=generate_video', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ avatar_id, voice_id, script, ratio, quality })
  });
  const data = await res.json().catch(() => ({}));
  if (!res.ok || !data || !data.success) {
    throw new Error('generate_video failed: ' + (data?.message || res.status));
  }
  // Expect { task_id }
  return data.task_id || data.data?.task_id;
}

async function heygenCheck(task_id) {
  const url = '/.netlify/functions/heygen-proxy?action=check_video&task_id=' + encodeURIComponent(task_id);
  const res = await fetch(url, { method: 'GET' });
  const data = await res.json().catch(() => ({}));
  if (!res.ok || !data || !data.success) {
    throw new Error('check_video failed: ' + (data?.message || res.status));
  }
  return {
    status: data.status || data.data?.status,
    video_url: data.video_url || data.data?.video_url,
    thumbnail_url: data.thumbnail_url || data.data?.thumbnail_url,
    duration: data.duration || data.data?.duration
  };
}

function ensureArrays(persona) {
  if (!Array.isArray(persona.videos)) persona.videos = [];
  if (!Array.isArray(persona.prompts) || persona.prompts.length === 0) {
    persona.prompts = DEFAULT_PROMPTS;
  }
  if (!persona.meta) persona.meta = {};
  if (!persona.heygen) persona.heygen = {};
  if (!persona.voice) persona.voice = {};
}

function hasAllVideos(persona) {
  const keysNeeded = (persona.prompts || DEFAULT_PROMPTS).map(p => p.key);
  const got = new Set((persona.videos || []).map(v => v.key || v.prompt || v.id));
  return keysNeeded.every(k => got.has(k));
}

async function processOnePersona(store, personaKey, maxPollMs = 180000) {
  const persona = await readPersona(store, personaKey);
  if (!persona) return { key: personaKey, status: 'skip', reason: 'missing' };

  ensureArrays(persona);

  // If already ready and has videos, skip
  if (persona.status === 'ready' && hasAllVideos(persona)) {
    return { key: personaKey, status: 'ready' };
  }

  const avatar_id = persona?.heygen?.avatar_id || persona?.heygen_avatar_id;
  const voice_id  = persona?.voice?.id || persona?.voice_id || persona?.elevenlabs_voice_id;
  if (!avatar_id || !voice_id) {
    // We can’t render without both
    return { key: personaKey, status: 'skip', reason: 'missing avatar or voice' };
  }

  // Build an index for existing videos by key
  const videoByKey = new Map();
  for (const v of persona.videos) {
    const k = (v.key || v.prompt || v.id);
    if (k) videoByKey.set(k, v);
  }

  const pending = persona.pending || {}; // { fun:{task_id}, ... }
  let launched = 0;

  // Kick off any missing renders
  for (const p of persona.prompts) {
    const k = p.key || p.id || 'unknown';
    if (videoByKey.has(k)) continue;              // already have video
    if (pending[k]?.task_id) continue;            // already rendering

    const script = p.text || p.prompt || p.script || `Tell me about ${k}.`;
    try {
      const task_id = await heygenGenerate({ avatar_id, voice_id, script });
      if (!persona.pending) persona.pending = {};
      persona.pending[k] = { task_id, started_at: Date.now() };
      launched++;
    } catch (e) {
      console.error('[processor] launch failed', personaKey, k, e?.message);
      if (!persona.failures) persona.failures = {};
      persona.failures[k] = String(e?.message || e);
    }
  }

  if (launched > 0) {
    persona.status = 'processing';
    await writePersona(store, personaKey, persona);
  }

  // Poll existing tasks for up to maxPollMs
  const start = Date.now();
  let anyCompleted = false;

  while (Date.now() - start < maxPollMs) {
    let remaining = 0;

    for (const [k, info] of Object.entries(persona.pending || {})) {
      if (videoByKey.has(k)) continue; // already have
      if (!info?.task_id) continue;

      try {
        const res = await heygenCheck(info.task_id);
        if (res.status === 'completed' && res.video_url) {
          // Save the video
          persona.videos.push({
            key: k,
            url: res.video_url,
            thumbnail_url: res.thumbnail_url || null,
            duration: res.duration || null
          });
          videoByKey.set(k, true);
          anyCompleted = true;
        } else if (res.status === 'failed') {
          if (!persona.failures) persona.failures = {};
          persona.failures[k] = 'render failed';
        } else {
          remaining++;
        }
      } catch (e) {
        console.warn('[processor] poll error', personaKey, k, e?.message);
        remaining++;
      }
    }

    // If nothing remaining to poll, break
    if (remaining === 0) break;

    // Throttle a bit between polls
    await sleep(3500);
  }

  // Clean up finished tasks from pending
  if (persona.pending) {
    for (const k of Object.keys(persona.pending)) {
      if (videoByKey.has(k)) delete persona.pending[k];
    }
    if (Object.keys(persona.pending).length === 0) delete persona.pending;
  }

  // Final status
  persona.status = hasAllVideos(persona) ? 'ready' : 'processing';
  await writePersona(store, personaKey, persona);

  return { key: personaKey, status: persona.status, completedNow: anyCompleted };
}

exports.handler = async (event) => {
  try {
    if (event.httpMethod === 'OPTIONS') return { statusCode: 204, headers: CORS, body: '' };

    const store = uploadsStore();

    // Find all persona JSON blobs
    const list = await store.list({ prefix: 'personas/' });
    const items = (list?.blobs || list || []).filter(x => String(x?.key || x).endsWith('.json'));

    const results = [];
    for (const item of items) {
      const key = item.key || item;
      const res = await processOnePersona(store, key);
      results.push(res);
    }

    return ok({ ok: true, processed: results.length, results });
  } catch (e) {
    console.error('[processor] fatal', e);
    return err(500, 'processor failed', { message: String(e?.message || e) });
  }
};
